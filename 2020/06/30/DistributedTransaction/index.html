<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="DistributedTransaction"><meta name="keywords" content="Distribution"><meta name="author" content="Jiayi Yang"><meta name="copyright" content="Jiayi Yang"><title>DistributedTransaction | Blog of JiayiY</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"4U85N5WHN0","apiKey":"41907345c92be9403ed9f1eadef3f632","indexName":"dev_blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.2.0'
} </script><meta name="generator" content="Hexo 5.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.</span> <span class="toc-text">分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">事务简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.2.</span> <span class="toc-text">什么是分布式事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">1.3.</span> <span class="toc-text">实现思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E6%AE%B5%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.3.1.</span> <span class="toc-text">两段式事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AE%B5%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.3.2.</span> <span class="toc-text">三段式事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EXA%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.3.3.</span> <span class="toc-text">基于XA的分布式事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%B6%88%E6%81%AF%E7%9A%84%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.4.</span> <span class="toc-text">基于消息的最终一致性方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCC%E7%BC%96%E7%A8%8B%E5%BC%8F%E8%A1%A5%E5%81%BF%E6%80%A7%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.3.5.</span> <span class="toc-text">TCC编程式补偿性事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">举例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6"><span class="toc-number">1.4.</span> <span class="toc-text">分布式事务框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCC-Transaction%E5%88%86%E6%9E%90"><span class="toc-number">1.5.</span> <span class="toc-text">TCC-Transaction分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.1.</span> <span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.5.2.</span> <span class="toc-text">源码分析</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i.bmp.ovh/imgs/2021/06/648ee42f65e461cd.jpg"></div><div class="author-info__name text-center">Jiayi Yang</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">55</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">18</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.bmp.ovh/imgs/2021/06/b914bf63a6c6a1d2.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Blog of JiayiY</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">DistributedTransaction</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-30</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h2 id="事务简介"><a href="#事务简介" class="headerlink" title="事务简介"></a>事务简介</h2><ul>
<li>事务是用来保证一组数据操作的完整性和一致性</li>
<li>事务必须满足ACID的四大特性（待补全）</li>
<li>事务具有四种隔离级别（待补全）</li>
<li>事务具有七种传播行为（待补全）</li>
</ul>
<a id="more"></a>

<h2 id="什么是分布式事务"><a href="#什么是分布式事务" class="headerlink" title="什么是分布式事务"></a>什么是分布式事务</h2><p>分布式事务就是将多个节点的事务看成一个整体处理。</p>
<p>分布式事务由事务参与者、资源服务器、事务管理器等组成，常见例子有，支付、下订单等。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="两段式事务"><a href="#两段式事务" class="headerlink" title="两段式事务"></a>两段式事务</h3><p><img src="/2020/06/30/DistributedTransaction/3.png" alt="两段式事务"></p>
<p>请求阶段：协调者向参与者询问是否可以进行事务提交操作，然后开始等待参与者的响应。</p>
<p>提交阶段：在该阶段，协调者将基于第一个阶段的投票结果进行决策：提交或取消。当且仅当所有的参与者同意提交，事务协调者才通知所有的参与者提交事务，否则协调者将通知所有的参与者回滚事务。</p>
<p>缺点：1）当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态；2）当协调者出错，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作；3）假如在第二阶段中，假如协调者发出commit消息后宕机，接收到这条消息的参与者宕机，此时则无法判断事务状态，无法确定是否已被提交；</p>
<h3 id="三段式事务"><a href="#三段式事务" class="headerlink" title="三段式事务"></a>三段式事务</h3><p>事务询问 -&gt; 执行事务预提交 -&gt; 进行事务提交或者事务回滚</p>
<p>降低了参与者的阻塞范围，但引入了新问题：在参与者接收到precommit后，网络出现问题，参与者和协调者无法通行，在这种情况下，参与者依然会执行事务的提交。</p>
<h3 id="基于XA的分布式事务"><a href="#基于XA的分布式事务" class="headerlink" title="基于XA的分布式事务"></a>基于XA的分布式事务</h3><p><img src="/2020/06/30/DistributedTransaction/4.png" alt="基于XA的分布式事务"></p>
<p>缺点：1）性能较差；2）很多nosql不支持XA协议；</p>
<h3 id="基于消息的最终一致性方案"><a href="#基于消息的最终一致性方案" class="headerlink" title="基于消息的最终一致性方案"></a>基于消息的最终一致性方案</h3><p><img src="/2020/06/30/DistributedTransaction/5.png" alt="基于消息的最终一致性方案"></p>
<p>缺点：属于强一致性事务，会存在资源浪费</p>
<h3 id="TCC编程式补偿性事务"><a href="#TCC编程式补偿性事务" class="headerlink" title="TCC编程式补偿性事务"></a>TCC编程式补偿性事务</h3><p><img src="/2020/06/30/DistributedTransaction/6.png" alt="TCC补偿性事务"></p>
<p>TCC事务是柔性事务，在try阶段要对资源做预留，在confirm或cancel阶段释放资源，与基于消息事务对比，TCC的时效性更好。</p>
<p>TCC模型是把锁的粒度完全交给业务处理，它分为三个阶段：</p>
<ol>
<li>Try阶段主要是对业务系统做检测及资源预留；</li>
<li>如果try阶段所有业务资源都预留成功，则执行confirm，否则执行cancel；</li>
</ol>
<ul>
<li>confirm：不做任务业务检查，仅使用预留的资源执行业务操作，失败会重试；</li>
<li>cancel：取消执行业务操作，释放预留的资源，失败会重试；</li>
</ul>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>以简单的电商系统为例，小明在淘宝上花100元买了一本书，获赠10个积分，产生如下操作：</p>
<ul>
<li>订单系统创建商品订单；</li>
<li>支付系统接受小明的支付；</li>
<li>库存系统扣减产品库存；</li>
<li>会员系统给小明账户增加会员积分；</li>
</ul>
<p>这几个动作需要作为一个事务执行，要同时成功或者同时撤销。如果采用TCC事务模式，那么各个系统需要改造为如下状态：</p>
<blockquote>
<p>1）订单系统</p>
<p>try：创建一个订单，状态显示为“待支付”；</p>
<p>confirm：更新订单的状态为“已完成”；</p>
<p>cancel：更新订单的状态为“已取消”；<br>2）支付系统</p>
<p>try：假设小明账户中有1000元，冻结小明账户中的100元，此时小明看到的余额依然是1000元；</p>
<p>confirm：将账户余额变为900元，并清除冻结记录；</p>
<p>concel：清除冻结记录；<br>3）库存系统</p>
<p>try：假设库存中还生10本书，冻结其中的一本书，现实库存依然有10本书；</p>
<p>confirm：将剩余库存更新为9本书，并清除冻结记录；</p>
<p>cancel：清除冻结记录；<br>4）会员系统</p>
<p>try：假设小明原因积分为3000，给小明账户预增加10积分，账户显示的积分依然是3000分；</p>
<p>confirm：将账户积分更新为3010，并清除预增加记录；</p>
<p>cancel：清除预增加记录；</p>
</blockquote>
<p>缺点：TCC 事务模型对业务方侵入较大，需要业务方把功能的实现上由一个接口拆分为三个，开发成本较高。</p>
<p>同时 TCC 事务为了解决异步网络中的通信失败或超时带来的异常情况，要求业务方在设计实现上要遵循三个策略：</p>
<ul>
<li><p>允许空回滚：原因是异常发生在阶段 1 时，部分参与方没有收到 try 请求从而触发整个事务的 cancel 操作，try 失败或者没有执行 try 操作的参与方收到 cancel 请求时，要进行空回滚操作；</p>
</li>
<li><p>保持幂等性：原因是异常发生在阶段 2 时，比如网络超时，则会重复调用参与方的 confirm/cancel 方法，因此需要这两个方法实现上保证幂等性；</p>
</li>
<li><p>防止资源悬挂：原因网络异常导致两个阶段无法保证严格的顺序执行，出现参与方侧 try 请求比 cancel 请求更晚到达的情况，cancel 会执行空回滚而确保事务的正确性，但是此时 try 方法也不可以再被执行；</p>
</li>
</ul>
<h2 id="分布式事务框架"><a href="#分布式事务框架" class="headerlink" title="分布式事务框架"></a>分布式事务框架</h2><ul>
<li><p>全局事务框架GTS</p>
</li>
<li><p>蚂蚁金服分布式事务DTX</p>
</li>
<li><p>开源TCC框架TCC-Transaction（<a target="_blank" rel="noopener" href="https://github.com/changmingxie/tcc-transaction%EF%BC%89">https://github.com/changmingxie/tcc-transaction）</a></p>
</li>
<li><p>开源TCC框架Byte-（<a target="_blank" rel="noopener" href="https://github.com/liuyangming/ByteTCC%EF%BC%89">https://github.com/liuyangming/ByteTCC）</a></p>
</li>
</ul>
<h2 id="TCC-Transaction分析"><a href="#TCC-Transaction分析" class="headerlink" title="TCC-Transaction分析"></a>TCC-Transaction分析</h2><p><img src="/2020/06/30/DistributedTransaction/7.png" alt="TCC-Transaction-Core"></p>
<p>仓库：<a target="_blank" rel="noopener" href="https://github.com/changmingxie/tcc-transaction">https://github.com/changmingxie/tcc-transaction</a></p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li>在需要提供分布式事务支持的接口方法上添加 <code>@Compensable</code>；</li>
<li>在对应的接口实现方法上也添加 @Compensable，并添加注解参数 <code>confirmMethod</code>, <code>cancelMethod</code> 和 <code>transactionContextEditor</code>；</li>
<li>实现对应的 <code>confirmMethod</code> 和 <code>cancelMethod</code>（必须和 try 方法在同一个类中）；</li>
</ol>
<p>注意：</p>
<ol>
<li>在分布式事务框架中，不要轻易在业务层捕获所有异常，只有在抛出异常的情况下，分布式事务框架才知道该业务是执行失败的，继而执行<code>cancelMethod</code>；</li>
<li>使用 TCC-Transaction 时，confirm 和 cancel 的幂等性问题需要人为代码保证；</li>
<li>TCC 的数据库应该和业务数据库分开，以保证分布式事务的正常进行；</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><img src="/2020/06/30/DistributedTransaction/8.png" alt="框架调用流程"></p>
<p>tcc的事务并不是数据库的事务，而是应用层的事务，Transaction如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7291423944314337931L</span>;</span><br><span class="line">    <span class="comment">// 全局事务id，用来保证事务唯一性</span></span><br><span class="line">    <span class="keyword">private</span> TransactionXid xid;</span><br><span class="line">    <span class="comment">// 事务的状态</span></span><br><span class="line">    <span class="keyword">private</span> TransactionStatus status;</span><br><span class="line">    <span class="comment">// 事务类型，ROOT是主事务，BRANCH是分支事务</span></span><br><span class="line">    <span class="keyword">private</span> TransactionType transactionType;</span><br><span class="line">	<span class="comment">// 事务重试次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> retriedCount = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 事务创建时间</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime = <span class="keyword">new</span> Date();</span><br><span class="line">	<span class="comment">// 事务最后一次更新的时间</span></span><br><span class="line">    <span class="keyword">private</span> Date lastUpdateTime = <span class="keyword">new</span> Date();</span><br><span class="line">	<span class="comment">// 事务的版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> version = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 事务的参与者</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Participant&gt; participants = <span class="keyword">new</span> ArrayList&lt;Participant&gt;();</span><br><span class="line">	<span class="comment">// 附加参数</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; attachments = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CompensableTransactionAspect是一个AOP切面类，<code>@Pointcut</code> 将 <code>@Compensable</code> 注解标记为切入点，其签名为<code>compensableService()</code>。<code>@Around</code> 表示在<code>compensableService()</code>之前和之后调用 <code>interceptCompensableMethod()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CompensableTransactionAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CompensableTransactionInterceptor compensableTransactionInterceptor;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCompensableTransactionInterceptor</span><span class="params">(CompensableTransactionInterceptor compensableTransactionInterceptor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.compensableTransactionInterceptor = compensableTransactionInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(org.mengyun.tcctransaction.api.Compensable)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compensableService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Around(&quot;compensableService()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interceptCompensableMethod</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compensableTransactionInterceptor.interceptCompensableMethod(pjp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CompensableTransactionInterceptor是事务拦截器，具有以下作用：</p>
<ol>
<li>将事务区分为ROOT事务和PROVIDER分支事务；</li>
<li>不断地修改数据库内的状态（初始化事务、修改事务状态）；</li>
<li>修改和清除事务管理区中的事务队列；</li>
<li>并没有执行目标对象方法，pjp.proceed() 其实是交给了下一个拦截器 ResourceCoordinatorInterceptor；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompensableMethodContext</span> </span>&#123;</span><br><span class="line">    ProceedingJoinPoint pjp = <span class="keyword">null</span>;</span><br><span class="line">    Method method = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">// 解析得到的Compensable注解</span></span><br><span class="line">    Compensable compensable = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Propagation propagation = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">// 保存了全局事务id和事务状态，在调用事务参与者Participant的confirm或cancel方法时会传递过去。</span></span><br><span class="line">    TransactionContext transactionContext = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CompensableMethodContext</span><span class="params">(ProceedingJoinPoint pjp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pjp = pjp;</span><br><span class="line">        <span class="keyword">this</span>.method = getCompensableMethod();</span><br><span class="line">        <span class="keyword">this</span>.compensable = method.getAnnotation(Compensable.class);</span><br><span class="line">        <span class="keyword">this</span>.propagation = compensable.propagation();</span><br><span class="line">        <span class="keyword">this</span>.transactionContext = FactoryBuilder.factoryOf(compensable.transactionContextEditor()).getInstance().get(pjp.getTarget(), method, pjp.getArgs());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompensableTransactionInterceptor</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">interceptCompensableMethod</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    	<span class="comment">// 通过pjp解析各种属性，组成CompansableMethodContext对象</span></span><br><span class="line">    	CompensableMethodContext compensableMethodContext = <span class="keyword">new</span> CompensableMethodContext(pjp);</span><br><span class="line">    	<span class="comment">// 是否有存在的事务队列（从ThreadLocal获取transactions来判断当前线程是否已经有事务）</span></span><br><span class="line">    	<span class="keyword">boolean</span> isTransactionActive = transactionManager.isTransactionActive();</span><br><span class="line">    	<span class="keyword">if</span> (!TransactionUtils.isLegalTransactionContext(isTransactionActive, compensableMethodContext)) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> SystemException(<span class="string">&quot;no active compensable transaction while propagation is mandatory for method &quot;</span> + compensableMethodContext.getMethod().getName());</span><br><span class="line">    	&#125;</span><br><span class="line">		<span class="comment">// 获取并判断当前事务的角色（ROOT表示主事务，PROVIDER表示分支事务或事务参与者），并根据其角色调用不同的方法来处理。</span></span><br><span class="line">    	<span class="keyword">switch</span> (compensableMethodContext.getMethodRole(isTransactionActive)) &#123;</span><br><span class="line">        	<span class="comment">// 处理主事务切面</span></span><br><span class="line">        	<span class="keyword">case</span> ROOT:</span><br><span class="line">            	<span class="keyword">return</span> rootMethodProceed(compensableMethodContext);</span><br><span class="line">        	<span class="comment">// 处理PROVIDER事务切面</span></span><br><span class="line">        	<span class="keyword">case</span> PROVIDER:</span><br><span class="line">            	<span class="keyword">return</span> providerMethodProceed(compensableMethodContext);</span><br><span class="line">        	<span class="keyword">default</span>:</span><br><span class="line">            	<span class="keyword">return</span> pjp.proceed();</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 开启全局事务</span></span><br><span class="line"><span class="comment">     * 2. 持久化全局事务</span></span><br><span class="line"><span class="comment">     * 3. 注册全局事务</span></span><br><span class="line"><span class="comment">     * 4. 判断应该是confirm还是cancel</span></span><br><span class="line"><span class="comment">     * 5. 清除事务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> compensableMethodContext</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">rootMethodProceed</span><span class="params">(CompensableMethodContext compensableMethodContext)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object returnValue = <span class="keyword">null</span>;</span><br><span class="line">        Transaction transaction = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> asyncConfirm = compensableMethodContext.getAnnotation().asyncConfirm();</span><br><span class="line">        <span class="keyword">boolean</span> asyncCancel = compensableMethodContext.getAnnotation().asyncCancel();</span><br><span class="line">        Set&lt;Class&lt;? extends Exception&gt;&gt; allDelayCancelExceptions = <span class="keyword">new</span> HashSet&lt;Class&lt;? extends Exception&gt;&gt;();</span><br><span class="line">        allDelayCancelExceptions.addAll(<span class="keyword">this</span>.delayCancelExceptions);</span><br><span class="line">        	allDelayCancelExceptions.addAll(Arrays.asList(compensableMethodContext.getAnnotation().delayCancelExceptions()));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 开启一个全新的事务</span></span><br><span class="line"><span class="comment">             * 1. 持久化事务形态 -&gt; 全局事务编号</span></span><br><span class="line"><span class="comment">             * 2. 注册一个事务【ThreadLocal】</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            transaction = transactionManager.begin(compensableMethodContext.getUniqueIdentity());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行后续方法</span></span><br><span class="line">                returnValue = compensableMethodContext.proceed();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable tryingException) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isDelayCancelException(tryingException, allDelayCancelExceptions)) &#123;</span><br><span class="line">                    logger.warn(String.format(<span class="string">&quot;compensable transaction trying failed. transaction content:%s&quot;</span>, JSON.toJSONString(transaction)), tryingException);</span><br><span class="line">                    <span class="comment">// 回滚事务</span></span><br><span class="line">                    transactionManager.rollback(asyncCancel);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> tryingException;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 提交事务</span></span><br><span class="line">            transactionManager.commit(asyncConfirm);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清除队列中的事务</span></span><br><span class="line">            transactionManager.cleanAfterCompletion(transaction);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">providerMethodProceed</span><span class="params">(CompensableMethodContext compensableMethodContext)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Transaction transaction = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> asyncConfirm = compensableMethodContext.getAnnotation().asyncConfirm();</span><br><span class="line">        <span class="keyword">boolean</span> asyncCancel = compensableMethodContext.getAnnotation().asyncCancel();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (TransactionStatus.valueOf(compensableMethodContext.getTransactionContext().getStatus())) &#123;</span><br><span class="line">                <span class="keyword">case</span> TRYING:</span><br><span class="line">                    <span class="comment">// 初始化一份事务参与者的数据进入到当前服务中，并向事务管理器注册事务</span></span><br><span class="line">                    transaction = transactionManager.propagationNewBegin(compensableMethodContext.getTransactionContext());</span><br><span class="line">                    <span class="keyword">return</span> compensableMethodContext.proceed();</span><br><span class="line">                <span class="keyword">case</span> CONFIRMING:</span><br><span class="line">                    <span class="comment">// 修改状态</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        transaction = transactionManager.propagationExistBegin(compensableMethodContext.getTransactionContext());</span><br><span class="line">                        <span class="comment">// 修改事务状态为CONFIRMING，并持久化更新，提交事务</span></span><br><span class="line">                        transactionManager.commit(asyncConfirm);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (NoExistedTransactionException excepton) &#123;</span><br><span class="line">                        <span class="comment">//the transaction has been commit,ignore it.</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> CANCELLING:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        transaction = transactionManager.propagationExistBegin(compensableMethodContext.getTransactionContext());</span><br><span class="line">                        <span class="comment">// 修改事务状态为 CANCELLING，并持久化更新，回滚事务</span></span><br><span class="line">                        transactionManager.rollback(asyncCancel);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (NoExistedTransactionException exception) &#123;</span><br><span class="line">                        <span class="comment">//the transaction has been rollback,ignore it.</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清除事务</span></span><br><span class="line">            transactionManager.cleanAfterCompletion(transaction);</span><br><span class="line">        &#125;</span><br><span class="line">        Method method = compensableMethodContext.getMethod();</span><br><span class="line">        <span class="keyword">return</span> ReflectionUtils.getNullValue(method.getReturnType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDelayCancelException</span><span class="params">(Throwable throwable, Set&lt;Class&lt;? extends Exception&gt;&gt; delayCancelExceptions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delayCancelExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Class delayCancelException : delayCancelExceptions) &#123;</span><br><span class="line">                Throwable rootCause = ExceptionUtils.getRootCause(throwable);</span><br><span class="line">                <span class="keyword">if</span> (delayCancelException.isAssignableFrom(throwable.getClass())</span><br><span class="line">                        || (rootCause != <span class="keyword">null</span> &amp;&amp; delayCancelException.isAssignableFrom(rootCause.getClass()))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TransactionManager</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TransactionRepository transactionRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Deque&lt;Transaction&gt;&gt; CURRENT = <span class="keyword">new</span> ThreadLocal&lt;Deque&lt;Transaction&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ExecutorService executorService;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启事务，持久化到repository，注册到ThreadLocal</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Transaction <span class="title">begin</span><span class="params">(Object uniqueIdentify)</span> </span>&#123;</span><br><span class="line">        Transaction transaction = <span class="keyword">new</span> Transaction(uniqueIdentify,TransactionType.ROOT);</span><br><span class="line">        transactionRepository.create(transaction);</span><br><span class="line">        registerTransaction(transaction);</span><br><span class="line">        <span class="keyword">return</span> transaction;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从主事务的上下文创建分支事务，xid不变，事务类型变化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Transaction <span class="title">propagationNewBegin</span><span class="params">(TransactionContext transactionContext)</span> </span>&#123;</span><br><span class="line">        Transaction transaction = <span class="keyword">new</span> Transaction(transactionContext);</span><br><span class="line">        transactionRepository.create(transaction);</span><br><span class="line">        registerTransaction(transaction);</span><br><span class="line">        <span class="keyword">return</span> transaction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从事务上下文同步事务状态到ThreadLocal</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Transaction <span class="title">propagationExistBegin</span><span class="params">(TransactionContext transactionContext)</span> <span class="keyword">throws</span> NoExistedTransactionException </span>&#123;</span><br><span class="line">        Transaction transaction = transactionRepository.findByXid(transactionContext.getXid());</span><br><span class="line">        <span class="keyword">if</span> (transaction != <span class="keyword">null</span>) &#123;</span><br><span class="line">            transaction.changeStatus(TransactionStatus.valueOf(transactionContext.getStatus()));</span><br><span class="line">            registerTransaction(transaction);</span><br><span class="line">            <span class="keyword">return</span> transaction;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoExistedTransactionException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> asyncCommit)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从ThreadLocal获取当前事务</span></span><br><span class="line">        <span class="keyword">final</span> Transaction transaction = getCurrentTransaction();</span><br><span class="line">        transaction.changeStatus(TransactionStatus.CONFIRMING);</span><br><span class="line">		<span class="comment">// 数据库更新transaction</span></span><br><span class="line">        transactionRepository.update(transaction);</span><br><span class="line">        <span class="keyword">if</span> (asyncCommit) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Long statTime = System.currentTimeMillis();</span><br><span class="line">                <span class="comment">// 通过线程池异步执行事务提交</span></span><br><span class="line">                executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        commitTransaction(transaction);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                logger.debug(<span class="string">&quot;async submit cost time:&quot;</span> + (System.currentTimeMillis() - statTime));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable commitException) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;compensable transaction async submit confirm failed, recovery job will try to confirm later.&quot;</span>, commitException);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConfirmingException(commitException);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 同步执行事务提交</span></span><br><span class="line">            commitTransaction(transaction);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">commitTransaction</span><span class="params">(Transaction transaction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用事务参与者的commit方法</span></span><br><span class="line">            transaction.commit();</span><br><span class="line">            <span class="comment">// 事务结束，在数据库删除当前事务，如果commit异常，不会删除数据库内事务记录，为了重试补偿</span></span><br><span class="line">            transactionRepository.delete(transaction);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable commitException) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;compensable transaction confirm failed, recovery job will try to confirm later.&quot;</span>, commitException);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConfirmingException(commitException);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> asyncRollback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Transaction transaction = getCurrentTransaction();</span><br><span class="line">        transaction.changeStatus(TransactionStatus.CANCELLING);</span><br><span class="line">        transactionRepository.update(transaction);</span><br><span class="line">        <span class="keyword">if</span> (asyncRollback) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        rollbackTransaction(transaction);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable rollbackException) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;compensable transaction async rollback failed, recovery job will try to rollback later.&quot;</span>, rollbackException);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> CancellingException(rollbackException);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rollbackTransaction(transaction);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 把transaction注册到ThreadLocal对象中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerTransaction</span><span class="params">(Transaction transaction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CURRENT.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CURRENT.set(<span class="keyword">new</span> LinkedList&lt;Transaction&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        CURRENT.get().push(transaction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务结束，从栈中弹出结束的事务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanAfterCompletion</span><span class="params">(Transaction transaction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isTransactionActive() &amp;&amp; transaction != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Transaction currentTransaction = getCurrentTransaction();</span><br><span class="line">            <span class="keyword">if</span> (currentTransaction == transaction) &#123;</span><br><span class="line">                CURRENT.get().pop();</span><br><span class="line">                <span class="keyword">if</span> (CURRENT.get().size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    CURRENT.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SystemException(<span class="string">&quot;Illegal transaction when clean after completion&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ResourceCoordinatorAspect：主要是为了设置事务的参与者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceCoordinatorAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ResourceCoordinatorInterceptor resourceCoordinatorInterceptor;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(org.mengyun.tcctransaction.api.Compensable)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transactionContextCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Around(&quot;transactionContextCall()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interceptTransactionContextMethod</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resourceCoordinatorInterceptor.interceptTransactionContextMethod(pjp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceCoordinatorInterceptor</span><span class="params">(ResourceCoordinatorInterceptor resourceCoordinatorInterceptor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceCoordinatorInterceptor = resourceCoordinatorInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ResourceCoordinatorInterceptor：主要处理 try 阶段的事情，在 try 阶段，就将所有的“资源”封装完成并交给事务管理器。然后事务管理器修改数据库状态。</p>
<p>“资源”指“事务资源”，即事务的参与者：confirm上下文，cancel上下文，分支事务信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceCoordinatorInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TransactionManager transactionManager;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransactionManager</span><span class="params">(TransactionManager transactionManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.transactionManager = transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interceptTransactionContextMethod</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">// 获取当前事务</span></span><br><span class="line">        Transaction transaction = transactionManager.getCurrentTransaction();</span><br><span class="line">        <span class="keyword">if</span> (transaction != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (transaction.getStatus()) &#123;</span><br><span class="line">				<span class="comment">// 只需要在trying时，获取到参与者信息，并设置到transaction中</span></span><br><span class="line">                <span class="keyword">case</span> TRYING:</span><br><span class="line">                    enlistParticipant(pjp);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> CONFIRMING:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> CANCELLING:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行目标方法</span></span><br><span class="line">        <span class="keyword">return</span> pjp.proceed(pjp.getArgs());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enlistParticipant</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">		<span class="comment">// 获取@Compensable注解信息</span></span><br><span class="line">        Method method = CompensableMethodUtils.getCompensableMethod(pjp);</span><br><span class="line">        <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(String.format(<span class="string">&quot;join point not found method, point is : %s&quot;</span>, pjp.getSignature().getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        Compensable compensable = method.getAnnotation(Compensable.class);</span><br><span class="line">        String confirmMethodName = compensable.confirmMethod();</span><br><span class="line">        String cancelMethodName = compensable.cancelMethod();</span><br><span class="line">        Transaction transaction = transactionManager.getCurrentTransaction();</span><br><span class="line">        TransactionXid xid = <span class="keyword">new</span> TransactionXid(transaction.getXid().getGlobalTransactionId());</span><br><span class="line">        <span class="keyword">if</span> (FactoryBuilder.factoryOf(compensable.transactionContextEditor()).getInstance().get(pjp.getTarget(), method, pjp.getArgs()) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            FactoryBuilder.factoryOf(compensable.transactionContextEditor()).getInstance().set(<span class="keyword">new</span> TransactionContext(xid, TransactionStatus.TRYING.getId()), pjp.getTarget(), ((MethodSignature) pjp.getSignature()).getMethod(), pjp.getArgs());</span><br><span class="line">        &#125;</span><br><span class="line">        Class targetClass = ReflectionUtils.getDeclaringType(pjp.getTarget().getClass(), method.getName(), method.getParameterTypes());</span><br><span class="line">        InvocationContext confirmInvocation = <span class="keyword">new</span> InvocationContext(targetClass,</span><br><span class="line">                confirmMethodName,</span><br><span class="line">                method.getParameterTypes(), pjp.getArgs());</span><br><span class="line">        InvocationContext cancelInvocation = <span class="keyword">new</span> InvocationContext(targetClass,</span><br><span class="line">                cancelMethodName,</span><br><span class="line">                method.getParameterTypes(), pjp.getArgs());</span><br><span class="line">        Participant participant =</span><br><span class="line">                <span class="keyword">new</span> Participant(</span><br><span class="line">                        xid,</span><br><span class="line">                        confirmInvocation,</span><br><span class="line">                        cancelInvocation,</span><br><span class="line">                        compensable.transactionContextEditor());</span><br><span class="line">        transactionManager.enlistParticipant(participant);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时经过两个拦截器后，才调用到目标对象方法，即对应try逻辑的被切方法。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css"></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Jiayi Yang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/06/30/DistributedTransaction/">http://yoursite.com/2020/06/30/DistributedTransaction/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Distribution/">Distribution</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/07/05/Lcof24/"><i class="fa fa-chevron-left">  </i><span>Lcof24</span></a></div><div class="next-post pull-right"><a href="/2020/06/30/SpringCode/"><span>SpringCode</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.bmp.ovh/imgs/2021/06/b914bf63a6c6a1d2.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Jiayi Yang</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/algolia.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.3" zIndex="-2" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>