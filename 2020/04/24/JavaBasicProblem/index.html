<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JavaBasicProblem"><meta name="keywords" content="Java"><meta name="author" content="Jiayi Yang"><meta name="copyright" content="Jiayi Yang"><title>JavaBasicProblem | Blog of JiayiY</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"4U85N5WHN0","apiKey":"41907345c92be9403ed9f1eadef3f632","indexName":"dev_blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.2.0'
} </script><meta name="generator" content="Hexo 5.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">Java基本数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">2.</span> <span class="toc-text">浏览器输入URL发生了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%AE%BA%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E8%BF%98%E6%98%AF%E7%BD%91%E7%BB%9C%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6%EF%BC%8C%E4%BF%A1%E6%81%AF%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E9%83%BD%E6%98%AF%E5%AD%97%E8%8A%82%EF%BC%8C%E9%82%A3%E4%B8%BA%E4%BB%80%E4%B9%88IO%E6%93%8D%E4%BD%9C%E8%BF%98%E8%A6%81%E5%88%86%E4%B8%BA%E5%AD%97%E8%8A%82%E6%B5%81%E6%93%8D%E4%BD%9C%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E6%93%8D%E4%BD%9C%E5%91%A2"><span class="toc-number">3.</span> <span class="toc-text">不论文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么IO操作还要分为字节流操作和字符流操作呢</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">深拷贝和浅拷贝的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-AOP%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.</span> <span class="toc-text">Spring AOP的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E5%92%8CLinkedList"><span class="toc-number">6.</span> <span class="toc-text">ArrayList和LinkedList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashMap%E5%92%8CTreeMap"><span class="toc-number">7.</span> <span class="toc-text">LinkedHashMap和TreeMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashcode-%E5%92%8Cequals"><span class="toc-number">8.</span> <span class="toc-text">hashcode()和equals()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97size"><span class="toc-number">9.</span> <span class="toc-text">ConcurrentHashMap如何计算size</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">10.</span> <span class="toc-text">使用Redis实现延迟消息队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88String%E6%98%AFfinal%E7%9A%84"><span class="toc-number">11.</span> <span class="toc-text">为什么String是final的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#count-%E5%92%8C-count-1-%E5%92%8Ccount-%E5%88%97%E5%90%8D-%E5%8C%BA%E5%88%AB"><span class="toc-number">12.</span> <span class="toc-text">count(*) 和 count(1)和count(列名)区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Springboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">13.</span> <span class="toc-text">Springboot启动流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">14.</span> <span class="toc-text">抽象类和接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAP"><span class="toc-number">15.</span> <span class="toc-text">CAP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#notify-%E5%92%8CnotifyAll-%E5%8C%BA%E5%88%AB"><span class="toc-number">16.</span> <span class="toc-text">notify()和notifyAll()区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sleep-%E5%92%8Cwait-%E5%8C%BA%E5%88%AB"><span class="toc-number">17.</span> <span class="toc-text">sleep()和wait()区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread%E7%B1%BB%E4%B8%ADinterrupt%EF%BC%88%EF%BC%89%E3%80%81interrupted%EF%BC%88%EF%BC%89%E5%92%8CisInterrupted%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">18.</span> <span class="toc-text">Thread类中interrupt（）、interrupted（）和isInterrupted（）方法详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Transactional%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">19.</span> <span class="toc-text">@Transactional实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OOP%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">20.</span> <span class="toc-text">OOP的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E5%9F%BA%E7%B1%BB"><span class="toc-number">21.</span> <span class="toc-text">集合的基类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">22.</span> <span class="toc-text">子类继承父类的初始化顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%92%8CTCP%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-number">23.</span> <span class="toc-text">HTTP和TCP的区别和联系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">24.</span> <span class="toc-text">二叉树 平衡二叉树 红黑树的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9B%B8%E7%AD%89%E4%B8%8E%E6%8C%87%E5%90%91%E4%BB%96%E4%BB%AC%E7%9A%84%E5%BC%95%E7%94%A8%E7%9B%B8%E7%AD%89-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">25.</span> <span class="toc-text">对象相等与指向他们的引用相等 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B9%8B%E5%89%8D%E4%BC%9A%E5%85%88%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">26.</span> <span class="toc-text">子类构造方法之前会先调用父类无参构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">27.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Servlet%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">28.</span> <span class="toc-text">Servlet生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8C%BA%E5%88%AB"><span class="toc-number">29.</span> <span class="toc-text">接口与抽象类区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CountDownLatch-%E5%92%8C-CyclicBarrier"><span class="toc-number">30.</span> <span class="toc-text">CountDownLatch 和 CyclicBarrier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">31.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">32.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Math%E7%B1%BB"><span class="toc-number">33.</span> <span class="toc-text">Math类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">34.</span> <span class="toc-text">枚举类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hibernate"><span class="toc-number">35.</span> <span class="toc-text">hibernate</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i.bmp.ovh/imgs/2021/06/648ee42f65e461cd.jpg"></div><div class="author-info__name text-center">Jiayi Yang</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">55</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">18</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.bmp.ovh/imgs/2021/06/b914bf63a6c6a1d2.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Blog of JiayiY</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">JavaBasicProblem</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-24</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>一些容易忘记的Java基础知识点：）</p>
<a id="more"></a>

<h2 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h2><table>
<thead>
<tr>
<th>类型名称</th>
<th>关键字</th>
<th>占用内存</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>字节型</td>
<td>byte</td>
<td>1字节</td>
<td>-128~127</td>
</tr>
<tr>
<td>短整型</td>
<td>short</td>
<td>2字节</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>整型</td>
<td>int</td>
<td>4字节</td>
<td>-2147483648~2147483647</td>
</tr>
<tr>
<td>长整型</td>
<td>long</td>
<td>8字节</td>
<td>-9223372036854775808L~9223372036854775807L</td>
</tr>
<tr>
<td>单精度浮点型</td>
<td>float</td>
<td>4字节</td>
<td>+/-3.4E+38F（6~7 个有效位）</td>
</tr>
<tr>
<td>双精度浮点型</td>
<td>double</td>
<td>8字节</td>
<td>+/-1.8E+308 (15 个有效位）</td>
</tr>
<tr>
<td>字符型</td>
<td>char</td>
<td>2字节</td>
<td>ISO 单一字符集</td>
</tr>
<tr>
<td>布尔型</td>
<td>boolean</td>
<td>1字节</td>
<td>true 或 false</td>
</tr>
</tbody></table>
<p>注：当需要将数值范围较大的数值类型赋给数值范围较小的数值类型变量时，此时可能会丢失精度，即强制类型转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">233</span>;</span><br><span class="line">    <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) a;</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：-23</span></span><br></pre></td></tr></table></figure>

<p>原因：233的二进制为：24位0 + 11101001，而byte只有8位，于是从高位开始舍弃，最后剩下：11101001，由于二进制最高位1表示负数，0表示正数，故其十进制输出为-23。</p>
<h2 id="浏览器输入URL发生了什么"><a href="#浏览器输入URL发生了什么" class="headerlink" title="浏览器输入URL发生了什么"></a>浏览器输入URL发生了什么</h2><ol>
<li>浏览器查找域名的IP地址（DNS解析，查找过程：浏览器缓存，路由器缓存，DNS缓存）；</li>
<li>建立TCP连接，浏览器向web服务器发送一个HTTP请求；</li>
<li>服务器处理请求并返回HTTP报文；</li>
<li>浏览器解析渲染页面；</li>
<li>连接结束；</li>
</ol>
<h2 id="不论文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么IO操作还要分为字节流操作和字符流操作呢"><a href="#不论文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么IO操作还要分为字节流操作和字符流操作呢" class="headerlink" title="不论文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么IO操作还要分为字节流操作和字符流操作呢"></a>不论文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么IO操作还要分为字节流操作和字符流操作呢</h2><p>字符流是由JVM将字节转换得到的，这个过程比较耗时，并且编码类型不确定会出现乱码问题。所以IO流提供了一个直接操作字符的接口，方便对字符进行流操作。如果是音频文件、图片等媒体文件用字节流比较好，涉及到字符的用字符流比较好。</p>
<h2 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h2><p>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝；<br>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝；</p>
<h2 id="Spring-AOP的实现"><a href="#Spring-AOP的实现" class="headerlink" title="Spring AOP的实现"></a>Spring AOP的实现</h2><p>当目标对象实现接口，Spring使用JDK动态代理；没有实现接口时，使用CGLIB实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultAopProxyFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!config.isOptimize() &amp;&amp; !config.isProxyTargetClass() &amp;&amp; !<span class="keyword">this</span>.hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">            <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (AopProxy)(!targetClass.isInterface() &amp;&amp; !Proxy.isProxyClass(targetClass) ? <span class="keyword">new</span> ObjenesisCglibAopProxy(config) : <span class="keyword">new</span> JdkDynamicAopProxy(config));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNoUserSuppliedProxyInterfaces</span><span class="params">(AdvisedSupport config)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt;[] ifcs = config.getProxiedInterfaces();</span><br><span class="line">        <span class="keyword">return</span> ifcs.length == <span class="number">0</span> || ifcs.length == <span class="number">1</span> &amp;&amp; SpringProxy.class.isAssignableFrom(ifcs[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015797402">https://segmentfault.com/a/1190000015797402</a></p>
<p>JDK动态代理：利用实现了InvocationHandler接口的拦截器加上反射机制生成一个实现代理接口的匿名类，然后通过invoke进行调用；生成类的速度很快，但运行时因为是基于反射，调用后续的类操作会很慢；</p>
<p>CGLIB动态代理：在内存中动态生成子类对原对象进行代理（直接继承原始类），无法代理final类以及方法；底层基于ASM第三方框架，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理，所以生成类的速度慢，后续执行类的操作快；</p>
<p>强制使用CGLIB实现AOP：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在spring配置文件中加入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="ArrayList和LinkedList"><a href="#ArrayList和LinkedList" class="headerlink" title="ArrayList和LinkedList"></a>ArrayList和LinkedList</h2><ol>
<li><p>LinkedList</p>
<p>实现了List接口和Deque接口的双端链表。LinkedList底层的链表结构使它支持高效的插入和删除操作，另外它实现了Deque接口，使得LinkedList类也具有队列的特性; LinkedList不是线程安全的，如果想使LinkedList变成线程安全的，可以调用静态类Collections类中的synchronizedList方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list=Collections.synchronizedList(<span class="keyword">new</span> LinkedList(...));</span><br></pre></td></tr></table></figure>

<p>LinkedList类中的内部私有类Node：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;<span class="comment">//节点值</span></span><br><span class="line">    Node&lt;E&gt; next;<span class="comment">//后继节点</span></span><br><span class="line">    Node&lt;E&gt; prev;<span class="comment">//前驱节点</span></span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。</p>
</li>
<li><p>ArrayList</p>
<ul>
<li>实现了<code>RandomAccess</code>接口，可以随机访问；</li>
<li>实现了<code>Cloneable</code>接口，可以克隆；</li>
<li>实现了<code>Serializable</code>接口，可以序列化、反序列化；</li>
<li>实现了<code>List</code>接口，是<code>List</code>的实现类之一；</li>
<li>实现了<code>Collection</code>接口，是<code>Java Collections Framework</code>成员之一；</li>
<li>实现了<code>Iterable</code>接口，可以使用<code>for-each</code>迭代；</li>
</ul>
<p>ArrayList底层使用数组实现存储，查询效率高，增删效率低，线程不安全。如果涉及频繁的增删，可以使用LinkedList，线程安全可以使用Vector。</p>
<p>通过无参构造方法的方式ArrayList()初始化，则赋值底层数Object[] elementData为一个默认空数组Object[]  DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}，所以数组容量为0，只有真正对数据进行添加add时，才分配默认DEFAULT_CAPACITY = 10的初始容量。</p>
<p>扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原数组的数据，原封不动的复制到新数组中，再把指向原数组的地址换到新数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，ArrayList（int initialCapacity）不会初始化数组大小，因为它基于elementData数组而不是大小。</p>
<p>ArrayList的遍历性能比LinkedList快很多，因为ArrayList是内存连续的，CPU的内部缓存结构会缓存连续的内存片段，可以大幅降低读取内存的性能开销，所以ArrayList遍历性能好。</p>
</li>
</ol>
<h2 id="LinkedHashMap和TreeMap"><a href="#LinkedHashMap和TreeMap" class="headerlink" title="LinkedHashMap和TreeMap"></a>LinkedHashMap和TreeMap</h2><p>LinkedHashMap内部维护了一个双向链表，保存了记录的插入顺序，因此可以按照插入的顺序从头部或者尾部迭代；</p>
<p>因为TreeMap实现了SortMap接口，将保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器。当用Iterator遍历TreeMap时，得到的记录是排过序的。TreeMap基于红黑树实现，非线程安全。</p>
<p>TreeMap()：构建一个空的映像树；</p>
<p>TreeMap(Map m)：构建一个映像树，并且添加映像m中所有元素；</p>
<p>TreeMap(Comparator c)：构建一个映像树，并且使用特定的比较器对关键字进行排序；</p>
<p>TreeMap(SortedMap s)：构建一个映像树，添加映像树s中所有映射，并且使用与有序映像s相同的比较器排序；</p>
<h2 id="hashcode-和equals"><a href="#hashcode-和equals" class="headerlink" title="hashcode()和equals()"></a>hashcode()和equals()</h2><p>==：比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。</p>
<p>equals()：是对两个对象的地址值进行的比较（即比较引用是否相同）。但是String 、Math、Integer、Double等这些封装类在使用equals()方法时，已经覆盖了object类的equals()方法，从而进行的是内容的比较。当然，基本类型是进行值的比较。</p>
<p>它的性质有：</p>
<ul>
<li><strong>自反性</strong>（reflexive）。对于任意不为<code>null</code>的引用值x，<code>x.equals(x)</code>一定是<code>true</code>。</li>
<li><strong>对称性</strong>（symmetric）。对于任意不为<code>null</code>的引用值<code>x</code>和<code>y</code>，当且仅当<code>x.equals(y)</code>是<code>true</code>时，<code>y.equals(x)</code>也是<code>true</code>。</li>
<li><strong>传递性</strong>（transitive）。对于任意不为<code>null</code>的引用值<code>x</code>、<code>y</code>和<code>z</code>，如果<code>x.equals(y)</code>是<code>true</code>，同时<code>y.equals(z)</code>是<code>true</code>，那么<code>x.equals(z)</code>一定是<code>true</code>。</li>
<li><strong>一致性</strong>（consistent）。对于任意不为<code>null</code>的引用值<code>x</code>和<code>y</code>，如果用于equals比较的对象信息没有被修改的话，多次调用时<code>x.equals(y)</code>要么一致地返回<code>true</code>要么一致地返回<code>false</code>。</li>
<li>对于任意不为<code>null</code>的引用值<code>x</code>，<code>x.equals(null)</code>返回<code>false</code>。</li>
</ul>
<p>对于<code>Object</code>类来说，<code>equals()</code>方法在对象上实现的是差别可能性最大的等价关系，即，对于任意非<code>null</code>的引用值<code>x</code>和<code>y</code>，当且仅当<code>x</code>和<code>y</code>引用的是同一个对象，该方法才会返回<code>true</code>。</p>
<p><strong>需要注意的是当<code>equals()</code>方法被override时，<code>hashCode()</code>也要被override。按照一般<code>hashCode()</code>方法的实现来说，相等的对象，它们的hash code一定相等。</strong></p>
<p>hashcode()：<code>hashCode()</code>方法给对象返回一个hash code值。</p>
<p>Java对于eqauls方法和hashCode方法是这样规定的：     </p>
<p>  1.如果两个对象相同，那么它们的hashCode值一定要相同；</p>
<p>  2.如果两个对象的hashCode相同，它们并不一定相同（这里说的对象相同指的是用eqauls方法比较）。<br>    如不按要求去做了，会发现相同的对象可以出现在Set集合中，同时，增加新元素的效率会大大下降。<br>  3.equals()相等的两个对象，hashcode()一定相等；equals()不相等的两个对象，却并不能证明他们的hashcode()不相等。</p>
<p>​    换句话说，equals()方法不相等的两个对象，hashcode()有可能相等（我的理解是由于哈希码在生成的时候产生冲突造成的）。反过来，hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等。</p>
<p>equals()被覆盖过，则hashcode()也必须被覆盖；</p>
<h2 id="ConcurrentHashMap如何计算size"><a href="#ConcurrentHashMap如何计算size" class="headerlink" title="ConcurrentHashMap如何计算size"></a>ConcurrentHashMap如何计算size</h2><h2 id="使用Redis实现延迟消息队列"><a href="#使用Redis实现延迟消息队列" class="headerlink" title="使用Redis实现延迟消息队列"></a>使用Redis实现延迟消息队列</h2><p>zset</p>
<h2 id="为什么String是final的"><a href="#为什么String是final的" class="headerlink" title="为什么String是final的"></a>为什么String是final的</h2><blockquote>
<p>final关键字的好处：</p>
<p>提高了性能，JVM和Java应用都会缓存final变量；</p>
<p>final变量可以安全的在多线程环境下进行共享，不需要额外的同步开销；</p>
<p>使用final关键字，JVM会对方法，变量及类进行优化；</p>
</blockquote>
<ul>
<li>只有当字符串是不可变的，字符串池才有可能实现，字符串池在运行时节约很多堆空间；</li>
<li>线程安全；</li>
<li>因为字符串不可变，创建时hashcode被缓存，不需要重新计算，使得字符串很适合作为Map的key；</li>
</ul>
<h2 id="count-和-count-1-和count-列名-区别"><a href="#count-和-count-1-和count-列名-区别" class="headerlink" title="count(*) 和 count(1)和count(列名)区别"></a>count(*) 和 count(1)和count(列名)区别</h2><p>count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL；</p>
<p>count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL；</p>
<p>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计；</p>
<p><strong>执行效率上：</strong></p>
<p>列名为主键，count(列名)会比count(1)快 ；<br>列名不为主键，count(1)会比count(列名)快；<br>如果表多个列并且没有主键，则 count（1） 的执行效率优于 count(*)；</p>
<p>如果有主键，则 select count（主键）的执行效率是最优的 ；<br>如果表只有一个字段，则 select count（*）最优；</p>
<h2 id="Springboot启动流程"><a href="#Springboot启动流程" class="headerlink" title="Springboot启动流程"></a>Springboot启动流程</h2><p>@SpringBootApplication包括三个注解，功能如下：</p>
<p>@EnableAutoConfiguration：SpringBoot根据应用所声明的依赖来对Spring框架进行自动配置；</p>
<p>@SpringBootConfiguration(内部为@Configuration)：被标注的类等于在spring的XML配置文件中(applicationContext.xml)，装配所有bean事务，提供了一个spring的上下文环境；</p>
<p>@ComponentScan：组件扫描，可自动发现和装配Bean，默认扫描SpringApplication的run方法里的Booter.class所在的包路径下文件，所以最好将该启动类放到根包路径下；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">        Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        configureHeadlessProperty();</span><br><span class="line"><span class="comment">//1.通过SpringFactoriesLoader查找并加载所有的SpringApplicationRunListeners，通过调用</span></span><br><span class="line"><span class="comment">//starting()方法通知所有的SpringApplicationRunListeners：应用开始启动了</span></span><br><span class="line">        SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">        listeners.starting();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//2.创建并配置当前应用将要使用的Environment</span></span><br><span class="line">            ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">                    args);</span><br><span class="line">            ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">                    applicationArguments);</span><br><span class="line">            configureIgnoreBeanInfo(environment);</span><br><span class="line"><span class="comment">//3.打印banner</span></span><br><span class="line">            Banner printedBanner = printBanner(environment);</span><br><span class="line"><span class="comment">//4.根据是否是web项目，来创建不同的ApplicationContext容器</span></span><br><span class="line">            context = createApplicationContext();</span><br><span class="line"><span class="comment">//5.创建一系列FailureAnalyzer</span></span><br><span class="line">            exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">                    SpringBootExceptionReporter.class,</span><br><span class="line">                    <span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line"><span class="comment">//6.初始化ApplicationContext</span></span><br><span class="line">            prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">                    printedBanner);</span><br><span class="line"><span class="comment">//7.调用ApplicationContext的refresh()方法,刷新容器</span></span><br><span class="line">            refreshContext(context);</span><br><span class="line"><span class="comment">//8.查找当前context中是否注册有CommandLineRunner和ApplicationRunner，如果有则遍历执行它们。</span></span><br><span class="line">            afterRefresh(context, applicationArguments);</span><br><span class="line">            stopWatch.stop();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">                <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">                        .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">            &#125;</span><br><span class="line">            listeners.started(context);</span><br><span class="line">            callRunners(context, applicationArguments);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            handleRunFailure(context, listeners, exceptionReporters, ex);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        listeners.running(context);</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>1.通过SpringFactoriesLoader查找并加载所有的SpringApplicationRunListeners，通过调用starting()方法通知所有的SpringApplicationRunListeners：应用开始启动了。（SpringApplicationRunListeners其本质上就是一个事件发布者，它在SpringBoot应用启动的不同时间点发布不同应用事件类型(ApplicationEvent)，如果有哪些事件监听者(ApplicationListener)对这些事件感兴趣，则可以接收并且处理）<br> 看下SpringApplicationRunListeners源码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">SpringApplicationRunListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行run方法时立即调用此方法，可以用户非常早期的初始化工作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">starting</span>(<span class="params"></span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Environment准备好后，并且ApplicationContext创建之前调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">environmentPrepared</span>(<span class="params">ConfigurableEnvironment environment</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ApplicationContext创建好后立即调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextPrepared</span>(<span class="params">ConfigurableApplicationContext context</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ApplicationContext加载完成，在refresh之前调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoaded</span>(<span class="params">ConfigurableApplicationContext context</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当run方法结束之前调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finished</span>(<span class="params">ConfigurableApplicationContext context, Throwable exception</span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringApplicationRunListener只有一个实现类：EventPublishingRunListener。①处的代码只会获取到一个EventPublishingRunListener的实例，我们来看看starting()方法的内容：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 发布一个ApplicationStartedEvent</span></span><br><span class="line">    <span class="keyword">this</span>.initialMulticaster.multicastEvent(<span class="keyword">new</span> ApplicationStartedEvent(<span class="keyword">this</span>.application, <span class="keyword">this</span>.args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.创建并配置当前应用将要使用的Environment，Environment用于描述应用程序当前的运行环境，其抽象了两个方面的内容：配置文件(profile)和属性(properties)，不同的环境(eg：生产环境、预发布环境)可以使用不同的配置文件，而属性则可以从配置文件、环境变量、命令行参数等来源获取。因此，当Environment准备好后，在整个应用的任何时候，都可以从Environment中获取资源。</p>
<blockquote>
<ul>
<li>判断Environment是否存在，不存在就创建（如果是web项目就创建StandardServletEnvironment，否则创建StandardEnvironment）</li>
<li>配置Environment：配置profile以及properties</li>
<li>调用SpringApplicationRunListener的environmentPrepared()方法，通知事件监听者：应用的Environment已经准备好</li>
</ul>
</blockquote>
<p>3.打印banner（可以自定义）<br>4.根据是否是web项目，来创建不同的ApplicationContext容器<br>5.创建一系列FailureAnalyzer，创建流程依然是通过SpringFactoriesLoader获取到所有实现FailureAnalyzer接口的class，然后在创建对应的实例。FailureAnalyzer用于分析故障并提供相关诊断信息。<br> 6.初始化ApplicationContext</p>
<ul>
<li>将准备好的Environment设置给ApplicationContext</li>
<li>遍历调用所有的ApplicationContextInitializer的initialize()方法来对已经创建好的ApplicationContext进行进一步的处理</li>
<li>调用SpringApplicationRunListener的contextPrepared()方法，通知所有的监听者：ApplicationContext已经准备完毕</li>
<li>将所有的bean加载到容器中</li>
<li>调用SpringApplicationRunListener的contextLoaded()方法，通知所有的监听者：ApplicationContext已经装载完毕</li>
</ul>
<p>7.调用ApplicationContext的refresh()方法,刷新容器</p>
<ul>
<li>这里的刷新和spring中刷新原理类似，这里重点关注invokeBeanFactoryPostProcessors(beanFactory);方法，主要完成获取到所有的BeanFactoryPostProcessor来对容器做一些额外的操作，通过源可以进入到PostProcessorRegistrationDelegate类<br> 的invokeBeanFactoryPostProcessors()方法，会获取类型为BeanDefinitionRegistryPostProcessor的beanorg.springframework.context.annotation.internalConfigurationAnnotationProcessor，对应的Class为ConfigurationClassPostProcessor。ConfigurationClassPostProcessor用于解析处理各种注解，包括：@Configuration、@ComponentScan、@Import、@PropertySource、@ImportResource、@Bean。当处理@import注解的时候，就会调用&lt;自动配置&gt;这一小节中的EnableAutoConfigurationImportSelector.selectImports()来完成自动配置功能</li>
</ul>
<p>8.查找当前context中是否注册有CommandLineRunner和ApplicationRunner，如果有则遍历执行它们。</p>
<h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><p>接口：</p>
<p>因为java不支持多重继承，所以有了接口，一个类只能继承一个父类，但可以实现多个接口，接口本身也可以继承多个接口。</p>
<p>接口里面的成员变量默认都是public static final类型的，必须被显示的初始化；接口里面的方法默认都是public abstract类型的，隐式声明；</p>
<p>接口没有构造方法，不能被实例化；</p>
<p>类如果实现了一个接口，那么必须实现接口里面的所有抽象方法，否则类要被定义为抽象类；</p>
<p>抽象类：</p>
<p>如果将一个类声明为abstract，此类不能生成对象，只能被继承使用；</p>
<p>抽象方法必须存在于抽象类中，抽象类中可以有一般的变量和一般的方法；</p>
<p>子类继承抽象类必须实现其中抽象方法，除非子类为抽象类；<br> private void print(){}；此语句表示方法的空实现。<br> abstract void print()； 此语句表示方法的抽象，无实现。</p>
<p><strong>区别：</strong></p>
<p>接口只能包含抽象方法，抽象类可以包含普通方法；</p>
<p>接口只能定义静态常量属性，抽象类既可以定义普通属性，也可以定义静态常量属性；</p>
<p>接口不包含构造方法，抽象类里可以包含构造方法；</p>
<p>抽象类中可以包含静态方法，接口中不能包含静态方法；</p>
<h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><p>一个分布式系统<strong>不可能同时满足</strong>一致性（ <code>C:Consistency</code> )，可用性（ <code>A: Availability</code> ）和分区容错性（ <code>P：Partition tolerance</code> ）这三个基本需求，<strong>最多只能同时满足其中的 2 个</strong>。</p>
<p>如下：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>C(Consistence)</code></td>
<td><strong>一致性</strong>，指数据在多个副本之间能够保持一致的特性（<strong>严格的一致性</strong>）。</td>
</tr>
<tr>
<td><code>A(Availability)</code></td>
<td><strong>可用性</strong>，指系统提供的服务必须一直处于可用的状态，每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据。</td>
</tr>
<tr>
<td><code>P(Network partitioning)</code></td>
<td><strong>分区容错性</strong>，分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障。</td>
</tr>
</tbody></table>
<p>分区：一个分布式系统，网络不通讯，导致连接不通，系统被分割成几个数据区域。</p>
<p>因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：<br>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。<br>CP - 满足一致性+分区 的系统，通常性能不是特别高。<br>AP - 满足可用性+分区 的系统，通常可能对一致性要求低一些。</p>
<h2 id="notify-和notifyAll-区别"><a href="#notify-和notifyAll-区别" class="headerlink" title="notify()和notifyAll()区别"></a>notify()和notifyAll()区别</h2><p>notify()只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现。</p>
<p>notifyAll 会唤醒所有等待(对象的)线程，哪一个线程将会第一个处理取决于操作系统的实现。</p>
<p>如果当前情况下有多个线程需要被唤醒，推荐使用notifyAll 方法。比如在生产者-消费者里面的使用，每次都需要唤醒所有的消费者或是生产者，以判断程序是否可以继续往下执行。</p>
<h2 id="sleep-和wait-区别"><a href="#sleep-和wait-区别" class="headerlink" title="sleep()和wait()区别"></a>sleep()和wait()区别</h2><ul>
<li>sleep() 是 Thread 类的静态本地方法；wait() 是Object类的成员本地方法</li>
<li>sleep() 方法可以在任何地方使用；wait() 方法则只能在同步方法或同步代码块中使用，否则抛出异常Exception in thread “Thread-0” java.lang.IllegalMonitorStateException</li>
<li>sleep() 会休眠当前线程指定时间，释放 CPU 资源，不释放对象锁，休眠时间到自动苏醒继续执行；wait() 方法放弃持有的对象锁，进入等待队列，当该对象被调用 notify() / notifyAll() 方法后才有机会竞争获取对象锁，进入运行状态</li>
<li>JDK1.8 sleep() wait() 均需要捕获 InterruptedException 异常</li>
</ul>
<h2 id="Thread类中interrupt（）、interrupted（）和isInterrupted（）方法详解"><a href="#Thread类中interrupt（）、interrupted（）和isInterrupted（）方法详解" class="headerlink" title="Thread类中interrupt（）、interrupted（）和isInterrupted（）方法详解"></a>Thread类中interrupt（）、interrupted（）和isInterrupted（）方法详解</h2><p>interrupt()：其作用是中断此线程（此线程不一定是当前线程，而是指调用该方法的Thread实例所代表的线程），但实际上只是给线程设置一个中断标志，线程仍会继续运行。</p>
<p>interrupted()：作用是测试当前线程是否被中断（检查中断标志），返回一个boolean并清除中断状态，第二次再调用时中断状态已经被清除，将返回一个false。</p>
<p>isInterrupted()：作用是只测试此线程是否被中断 ，不清除中断状态。</p>
<h2 id="Transactional实现原理"><a href="#Transactional实现原理" class="headerlink" title="@Transactional实现原理"></a>@Transactional实现原理</h2><h2 id="OOP的理解"><a href="#OOP的理解" class="headerlink" title="OOP的理解"></a>OOP的理解</h2><p>OOP是面向对象编程，特征是封装、继承、多态、抽象。<br>封装：是指将对象信息状态通过访问权限修饰符隐藏在对象内部，不允许外部程序直接访问，如果外部程序要访问对象内部，可以调用内部提供的get或set方法。简单来说，封装就是要找出某一类事务的公性然后提取出来。<br>继承：子类继承了父类所有的成员方法和属性，并且可以拥有自己特性。继承解决了代码的重用问题；<br>多态：多态存在的三个条件1.继承2.重写3.父类引用指向子类对象<br>多态的实现方式：接口实现，继承父类方法重写，同一个类中进行重载；<br>重载：多个同名函数同时存在，具有不同的参数个数/类型，返回值类型可以相同可以不同，调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性，存在于父类和子类、同类中；<br>重写：</p>
<p>​    1.参数列表必须完全与被重写的方法相同；<br>​    2.返回的类型必须一直与被重写的方法的返回类型相同；<br>​    3.访问修饰符的限制一定要大于被重写方法的访问修饰符；<br>​    4.重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常；<br>​    5.存在于父类和子类之间，方法被定义为final不能被重写；<br>抽象：如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。<br>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。</p>
<h2 id="集合的基类"><a href="#集合的基类" class="headerlink" title="集合的基类"></a>集合的基类</h2><h2 id="子类继承父类的初始化顺序"><a href="#子类继承父类的初始化顺序" class="headerlink" title="子类继承父类的初始化顺序"></a>子类继承父类的初始化顺序</h2><ol>
<li>父类的静态成员变量</li>
<li>父类的静态代码块</li>
<li>子类的静态成员变量</li>
<li>子类的静态代码块</li>
<li>父类的成员变量</li>
<li>父类的代码块</li>
<li>父类的构造函数</li>
<li>子类的成员变量</li>
<li>子类的代码块</li>
<li>子类的构造函数</li>
</ol>
<h2 id="HTTP和TCP的区别和联系"><a href="#HTTP和TCP的区别和联系" class="headerlink" title="HTTP和TCP的区别和联系"></a>HTTP和TCP的区别和联系</h2><p>1、TCP连接</p>
<p>   手机能够使用联网功能是因为手机底层实现了TCP/IP协议，可以使手机终端通过无线网络建立TCP连接。TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在“无差别”的网络之上。</p>
<p>   建立起一个TCP连接需要经过“三次握手”：</p>
<p>   第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；</p>
<p>   第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>   第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
<p>   握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连 接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”（过程就不细写 了，就是服务器和客户端交互，最终确定断开）<br>2、HTTP连接</p>
<p>   HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。</p>
<p>   HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。</p>
<p>   1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。</p>
<p>   2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。</p>
<p>   由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的 做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客 户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。</p>
<p>二者的区别和联系：</p>
<p>TCP是底层通讯协议，定义的是数据传输和连接方式的规范；</p>
<p>HTTP是应用层协议，定义的是传输数据的内容的规范；</p>
<p>TCP是传输层，而http是应用层；</p>
<p>HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP也就一定支持TCP；</p>
<h2 id="二叉树-平衡二叉树-红黑树的区别"><a href="#二叉树-平衡二叉树-红黑树的区别" class="headerlink" title="二叉树 平衡二叉树 红黑树的区别"></a>二叉树 平衡二叉树 红黑树的区别</h2><p>二叉查找/搜索/排序树  BST  (binary search/sort tree)<br>（1）若它的左子树不空，则左子树上所有结点的值均小于它的根节点的值；<br>（2）若它的右子树上所有结点的值均大于它的根节点的值；<br>（3）它的左、右子树也分别为二叉排序树。</p>
<p>注意：对二叉查找树进行中序遍历，得到有序集合。</p>
<p>平衡二叉树（Self-balancing binary search tree）  自平衡二叉查找树，又被称为AVL树：<br>它是一 棵空树或它的左右两个子树的高度差(平衡因子)的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树，同时，平衡二叉树必定是二叉搜索树，反之则不一定。</p>
<p>红黑树<br>   R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种平衡二叉树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p>
<p>红黑树的特性:<br>（1）每个节点或者是黑色，或者是红色。<br>（2）根节点是黑色。<br>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]<br>（4）如果一个节点是红色的，则它的子节点必须是黑色的。<br>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<h2 id="对象相等与指向他们的引用相等-的区别"><a href="#对象相等与指向他们的引用相等-的区别" class="headerlink" title="对象相等与指向他们的引用相等 的区别"></a>对象相等与指向他们的引用相等 的区别</h2><p>对象的相等，比的是内存中存放的内容是否相等；</p>
<p>引用相等，比较的是他们指向的内存地址是否相等；</p>
<h2 id="子类构造方法之前会先调用父类无参构造方法"><a href="#子类构造方法之前会先调用父类无参构造方法" class="headerlink" title="子类构造方法之前会先调用父类无参构造方法"></a>子类构造方法之前会先调用父类无参构造方法</h2><p>在子类构造器的第一行会隐式的调用 super()，即调用父类的构造器，如果父类中没有定义空参的构造器，则必须在子类的构造器的第一行显示的调用super(参数)，以调用父类中构造器；</p>
<p>帮助子类做初始化工作</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>四个条件：</p>
<p>互斥条件：该资源任意一个时刻只由一个线程占用；</p>
<p>请求与保持条件</p>
<p>不剥夺条件</p>
<p>循环等待条件</p>
<h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><p>Servlet的生命周期一般可以用三个方法来表示：</p>
<ol>
<li>init()：仅执行一次，负责在装载Servlet时初始化Servlet对象</li>
<li>service() ：核心方法，一般HttpServlet中会有get,post两种处理方式。在调用doGet和doPost方法时会构造servletRequest和servletResponse请求和响应对象作为参数。</li>
<li>destory()：在停止并且卸载Servlet时执行，负责释放资源</li>
</ol>
<p>初始化阶段：Servlet启动，会读取配置文件中的信息，构造指定的Servlet对象，创建ServletConfig对象，将ServletConfig作为参数来调用init()方法。</p>
<h2 id="接口与抽象类区别"><a href="#接口与抽象类区别" class="headerlink" title="接口与抽象类区别"></a>接口与抽象类区别</h2><p>A.抽象类可以有非抽象的方法，而接口中的方法都是抽象方法</p>
<p>B.java中类只能单继承，接口可以‘继承’多个接口</p>
<p>C.抽象类必须有构造方法，接口一定没有构造方法</p>
<p>D.实例化一般指new一个对象，所以抽象类不能实例化</p>
<p>关于抽象类</p>
<p>JDK 1.8以前，抽象类的方法默认访问权限为protected</p>
<p>JDK 1.8时，抽象类的方法默认访问权限变为default</p>
<p>关于接口</p>
<p>JDK 1.8以前，接口中的方法必须是public的</p>
<p>JDK 1.8时，接口中的方法可以是public的，也可以是default的</p>
<p>JDK 1.9时，接口中的方法可以是private的</p>
<h2 id="CountDownLatch-和-CyclicBarrier"><a href="#CountDownLatch-和-CyclicBarrier" class="headerlink" title="CountDownLatch 和 CyclicBarrier"></a>CountDownLatch 和 CyclicBarrier</h2><p>CountDownLatch 是等待一组线程执行完，才执行后面的代码。此时这组线程已经执行完。<br>CyclicBarrier 是等待一组线程至某个状态后再同时全部继续执行线程。此时这组线程还未执行完。</p>
<p><strong>CountDownLatch</strong> 允许一个线程或多个线程等待特定情况，同步完成线程中其他任务。举例：百米赛跑，就绪运动员等待发令枪发动才能起步。<br><strong>CyclicBarrier</strong> 和CountDownLatch一样都可以协同多个线程，让指定数量的线程等待期他所有的线程都满足某些条件之后才继续执行。举例：排队上摩天轮时，每到齐四个人，就可以上同一个车厢。</p>
<p>如果finally块中有return语句的话，它将覆盖掉函数中其他return语句。</p>
<p>interface中的方法默认为public abstract 的 ，变量默认为public static final</p>
<p>成员变量有初始值，而局部变量没有初始值得。变量没有初始值就使用了，编译通不过；</p>
<p>实际上这道题考查的是<strong>两同两小一大</strong>原则：</p>
<p>方法名相同，参数类型相同</p>
<p>子类返回类型小于等于父类方法返回类型，<br>子类抛出异常小于等于父类方法抛出异常，<br>子类访问权限大于等于父类方法访问权限。</p>
<p>Socket套接字 </p>
<p>就是源Ip地址，目标IP地址，源端口号和目标端口号的组合</p>
<p>服务器端：ServerSocket提供的实例</p>
<p>ServerSocket server= new ServerSocket(端口号)</p>
<p>客户端：Socket提供的实例</p>
<p>Socket soc=new Socket(ip地址，端口号)</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常是指程序运行时（非编译）所发生的非正常情况或错误，当程序违反了语音规则，jvm就会将出现的错误表示一个异常抛出。</p>
<p>异常也是java 的对象，定义了基类 java。lang。throwable作为异常父类。 这些异常类又包括error和exception。两大类</p>
<p>error类异常主要是运行时逻辑错误导致，一个正确程序中是不应该出现error的。当出现error一般jvm会终止。</p>
<p>exception表示可恢复异常，包括检查异常和运行时异常。 检查异常是最常见异常比如 io异常sql异常，都发生在编译阶段。这类通过try、catch捕捉</p>
<p>而运行时异常，编译器没有强制对其进行捕捉和处理。一般都会把异常向上抛出，直到遇到处理代码位置，若没有处理块就会抛到最上层，多线程用thread。run（）抛出，单线程用main（）抛出。常见的运行异常包括 空指针异常 类型转换异常 数组月结异常 数组存储异常 缓冲区溢出异常 算术异常等。</p>
<p><img src="/2020/04/24/JavaBasicProblem/exception.jpg" alt="Java异常"></p>
<ol>
<li><p>粉红色的是受检查的异常(checked exceptions),其必须被 try{}catch语句块所捕获,或者在方法签名里通过throws子句声明.受检查的异常必须在编译时被捕捉处理,命名为 Checked Exception 是因为Java编译器要进行检查,Java虚拟机也要进行检查,以确保这个规则得到遵守.</p>
</li>
<li><p>绿色的异常是运行时异常(runtime exceptions),需要程序员自己分析代码决定是否捕获和处理,比如 空指针,被0除…</p>
</li>
<li><p>而声明为Error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕捉。</p>
</li>
</ol>
<p>Java中的位运算符：</p>
<p>&gt;&gt;表示右移，如果该数为正，则高位补0，若为负数，则高位补1；</p>
<p>&gt;&gt;&gt;表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0。</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>(1)把类定义在另一个类的内部，该类就被称为内部类，举例：把类B定义在类A中，类B就被称为内部类。<br>(2)内部类的访问规则<br>可以直接访问外部类的成员，包括私有；<br>外部类要想访问内部类成员，必须创建对象；<br>(3)内部类的分类<br>成员内部类；局部内部类；匿名内部类</p>
<p>(4)成员内部类访问规则<br>成员内部类不是静态的：<br>外部类名.内部类名 对象名 = new 外部类名().new 内部类名();<br>成员内部类是静态的：</p>
<p>外部类名.内部类名 对象名 = new 外部类名.内部类名();</p>
<p>(5)局部内部类<br>局部内部类访问局部变量必须加final修饰，因为局部变量使用完毕就消失，而堆内存的数据并不会立即消失，所以，堆内存还是用该变量，而改变量已经没有了，为了让该值还存在，就加final修饰。<br>通过反编译工具我们看到了，加入final后，堆内存直接存储的是值，而不是变量名。<br>(6)匿名内部类(掌握)<br>是局部内部类的简化形式<br>前提：存在一个类或者接口<br>格式:<br>new 类名或者接口名() {<br>重写方法;<br>}<br>本质：其实是继承该类或者实现接口的子类匿名对象</p>
<blockquote>
<p>对于外部类来说，只有两种修饰，public和默认（default），因为外部类放在包中，只有两种可能，包可见和包不可见。</p>
<p>对于内部类来说，可以有所有的修饰，因为内部类放在外部类中，与成员变量的地位一致，所以有四种可能。</p>
</blockquote>
<h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>Math类中提供了三个与取整有关的方法：ceil,floor,round,这些方法的作用于它们的英文名称的含义相对应，例如：</p>
<p>ceil的英文意义是天花板，该方法就表示向上取整，Math.ceil（11.3）的结果为12，Math.ceil(-11.6)的结果为-11；</p>
<p>floor的英文是地板，该方法就表示向下取整，Math.floor(11.6)的结果是11，Math.floor(-11.4)的结果-12；</p>
<p>最难掌握的是round方法，他表示“四舍五入”，算法为Math.floor(x+0.5),即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果是12，Math.round(-11.5)的结果为-11.</p>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>枚举类 所有的枚举值都是类静态常量，在初始化时会对所有的枚举值对象进行第一次初始化。</p>
<p>重载就是一句话：同名不同参，返回值无关。</p>
<p>覆盖/重写：同名同参</p>
<h2 id="hibernate"><a href="#hibernate" class="headerlink" title="hibernate"></a>hibernate</h2><p>1、什么是延迟加载？<br>定义：延迟加载(lazy load)是Hibernate3 关联关系对象默认的加载方式，延迟加载机制是为了避免一些无谓的性能开销而提出来的。就是只有当真正需要数据时，才真正的执行数据加载操作。延迟加载是 hibernate 中用于提高查询效率的一种措施，它的对立面是 立即加载。<br>2、如何实现延迟加载？<br>Hibernate 2 实现延迟加载有 2 种方式：<br>实体对象<br>集合<br>Hibernate 3 又引入了一种新的加载方式：属性的延迟加载<br>一般使用load()的方法来实现延迟加载：<br>当调用load方法加载对象时，返回***对象，等到真正用到对象的内容时才发出sql语句<br>3、Hibernate 其他介绍<br>Hibernate 使用 Java 反射机制，而不是字节码增强程序来实现透明性<br>Hibernate 的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。<br>4、优化 Hibernate 所鼓励的 7 大措施<br>    1.尽量使用多对一，避免使用单项一对多<br>    2.灵活使用单向一对多<br>    3.不用一对一，使用多对一代替一对一<br>    4.配置对象缓存，不使用集合缓存<br>    5.一对多使用Bag ，多对一使用Set<br>    6.继承使用显示多态 HQL:from object polymorphism=”exlicit” 避免查处所有对象<br>    7.消除大表，使用二级缓存</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css"></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Jiayi Yang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/04/24/JavaBasicProblem/">http://yoursite.com/2020/04/24/JavaBasicProblem/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/05/05/ComputerNetwork/"><i class="fa fa-chevron-left">  </i><span>ComputerNetwork</span></a></div><div class="next-post pull-right"><a href="/2020/04/16/Lc-1115/"><span>Lc-1115</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.bmp.ovh/imgs/2021/06/b914bf63a6c6a1d2.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Jiayi Yang</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/algolia.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.3" zIndex="-2" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>