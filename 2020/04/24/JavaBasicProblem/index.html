<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>JavaBasicProblem - Blog of JiayiY</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Blog of JiayiY"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Blog of JiayiY"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="一些容易忘记的Java基础知识点：）"><meta property="og:type" content="blog"><meta property="og:title" content="JavaBasicProblem"><meta property="og:url" content="http://yoursite.com/2020/04/24/JavaBasicProblem/"><meta property="og:site_name" content="Blog of JiayiY"><meta property="og:description" content="一些容易忘记的Java基础知识点：）"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://yoursite.com/img/og_image.png"><meta property="article:published_time" content="2020-04-24T08:16:44.000Z"><meta property="article:modified_time" content="2020-09-21T15:45:48.242Z"><meta property="article:author" content="Jiayi Yang"><meta property="article:tag" content="Java"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2020/04/24/JavaBasicProblem/"},"headline":"Blog of JiayiY","image":["http://yoursite.com/img/og_image.png"],"datePublished":"2020-04-24T08:16:44.000Z","dateModified":"2020-09-21T15:45:48.242Z","author":{"@type":"Person","name":"Jiayi Yang"},"description":"一些容易忘记的Java基础知识点：）"}</script><link rel="canonical" href="http://yoursite.com/2020/04/24/JavaBasicProblem/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/darcula.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Blog of JiayiY" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-04-24T08:16:44.000Z" title="2020-04-24T08:16:44.000Z">2020-04-24</time>发表</span><span class="level-item"><time dateTime="2020-09-21T15:45:48.242Z" title="2020-09-21T15:45:48.242Z">2020-09-21</time>更新</span><span class="level-item">1 小时读完 (大约7611个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">JavaBasicProblem</h1><div class="content"><p>一些容易忘记的Java基础知识点：）</p>
<a id="more"></a>

<h2 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h2><table>
<thead>
<tr>
<th>类型名称</th>
<th>关键字</th>
<th>占用内存</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>字节型</td>
<td>byte</td>
<td>1字节</td>
<td>-128~127</td>
</tr>
<tr>
<td>短整型</td>
<td>short</td>
<td>2字节</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>整型</td>
<td>int</td>
<td>4字节</td>
<td>-2147483648~2147483647</td>
</tr>
<tr>
<td>长整型</td>
<td>long</td>
<td>8字节</td>
<td>-9223372036854775808L~9223372036854775807L</td>
</tr>
<tr>
<td>单精度浮点型</td>
<td>float</td>
<td>4字节</td>
<td>+/-3.4E+38F（6~7 个有效位）</td>
</tr>
<tr>
<td>双精度浮点型</td>
<td>double</td>
<td>8字节</td>
<td>+/-1.8E+308 (15 个有效位）</td>
</tr>
<tr>
<td>字符型</td>
<td>char</td>
<td>2字节</td>
<td>ISO 单一字符集</td>
</tr>
<tr>
<td>布尔型</td>
<td>boolean</td>
<td>1字节</td>
<td>true 或 false</td>
</tr>
</tbody></table>
<p>注：当需要将数值范围较大的数值类型赋给数值范围较小的数值类型变量时，此时可能会丢失精度，即强制类型转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">233</span>;</span><br><span class="line">    <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) a;</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：-23</span></span><br></pre></td></tr></table></figure>

<p>原因：233的二进制为：24位0 + 11101001，而byte只有8位，于是从高位开始舍弃，最后剩下：11101001，由于二进制最高位1表示负数，0表示正数，故其十进制输出为-23。</p>
<h2 id="浏览器输入URL发生了什么"><a href="#浏览器输入URL发生了什么" class="headerlink" title="浏览器输入URL发生了什么"></a>浏览器输入URL发生了什么</h2><ol>
<li>浏览器查找域名的IP地址（DNS解析，查找过程：浏览器缓存，路由器缓存，DNS缓存）；</li>
<li>建立TCP连接，浏览器向web服务器发送一个HTTP请求；</li>
<li>服务器处理请求并返回HTTP报文；</li>
<li>浏览器解析渲染页面；</li>
<li>连接结束；</li>
</ol>
<h2 id="不论文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么IO操作还要分为字节流操作和字符流操作呢"><a href="#不论文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么IO操作还要分为字节流操作和字符流操作呢" class="headerlink" title="不论文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么IO操作还要分为字节流操作和字符流操作呢"></a>不论文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么IO操作还要分为字节流操作和字符流操作呢</h2><p>字符流是由JVM将字节转换得到的，这个过程比较耗时，并且编码类型不确定会出现乱码问题。所以IO流提供了一个直接操作字符的接口，方便对字符进行流操作。如果是音频文件、图片等媒体文件用字节流比较好，涉及到字符的用字符流比较好。</p>
<h2 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h2><p>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝；<br>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝；</p>
<h2 id="Spring-AOP的实现"><a href="#Spring-AOP的实现" class="headerlink" title="Spring AOP的实现"></a>Spring AOP的实现</h2><p>当目标对象实现接口，Spring使用JDK动态代理；没有实现接口时，使用CGLIB实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultAopProxyFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!config.isOptimize() &amp;&amp; !config.isProxyTargetClass() &amp;&amp; !<span class="keyword">this</span>.hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">            <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (AopProxy)(!targetClass.isInterface() &amp;&amp; !Proxy.isProxyClass(targetClass) ? <span class="keyword">new</span> ObjenesisCglibAopProxy(config) : <span class="keyword">new</span> JdkDynamicAopProxy(config));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNoUserSuppliedProxyInterfaces</span><span class="params">(AdvisedSupport config)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt;[] ifcs = config.getProxiedInterfaces();</span><br><span class="line">        <span class="keyword">return</span> ifcs.length == <span class="number">0</span> || ifcs.length == <span class="number">1</span> &amp;&amp; SpringProxy.class.isAssignableFrom(ifcs[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015797402">https://segmentfault.com/a/1190000015797402</a></p>
<p>JDK动态代理：利用实现了InvocationHandler接口的拦截器加上反射机制生成一个实现代理接口的匿名类，然后通过invoke进行调用；生成类的速度很快，但运行时因为是基于反射，调用后续的类操作会很慢；</p>
<p>CGLIB动态代理：在内存中动态生成子类对原对象进行代理（直接继承原始类），无法代理final类以及方法；底层基于ASM第三方框架，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理，所以生成类的速度慢，后续执行类的操作快；</p>
<p>强制使用CGLIB实现AOP：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在spring配置文件中加入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="ArrayList和LinkedList"><a href="#ArrayList和LinkedList" class="headerlink" title="ArrayList和LinkedList"></a>ArrayList和LinkedList</h2><ol>
<li><p>LinkedList</p>
<p>实现了List接口和Deque接口的双端链表。LinkedList底层的链表结构使它支持高效的插入和删除操作，另外它实现了Deque接口，使得LinkedList类也具有队列的特性; LinkedList不是线程安全的，如果想使LinkedList变成线程安全的，可以调用静态类Collections类中的synchronizedList方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list=Collections.synchronizedList(<span class="keyword">new</span> LinkedList(...));</span><br></pre></td></tr></table></figure>

<p>LinkedList类中的内部私有类Node：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;<span class="comment">//节点值</span></span><br><span class="line">    Node&lt;E&gt; next;<span class="comment">//后继节点</span></span><br><span class="line">    Node&lt;E&gt; prev;<span class="comment">//前驱节点</span></span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。</p>
</li>
<li><p>ArrayList</p>
<ul>
<li>实现了<code>RandomAccess</code>接口，可以随机访问；</li>
<li>实现了<code>Cloneable</code>接口，可以克隆；</li>
<li>实现了<code>Serializable</code>接口，可以序列化、反序列化；</li>
<li>实现了<code>List</code>接口，是<code>List</code>的实现类之一；</li>
<li>实现了<code>Collection</code>接口，是<code>Java Collections Framework</code>成员之一；</li>
<li>实现了<code>Iterable</code>接口，可以使用<code>for-each</code>迭代；</li>
</ul>
<p>ArrayList底层使用数组实现存储，查询效率高，增删效率低，线程不安全。如果涉及频繁的增删，可以使用LinkedList，线程安全可以使用Vector。</p>
<p>通过无参构造方法的方式ArrayList()初始化，则赋值底层数Object[] elementData为一个默认空数组Object[]  DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}，所以数组容量为0，只有真正对数据进行添加add时，才分配默认DEFAULT_CAPACITY = 10的初始容量。</p>
<p>扩容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原数组的数据，原封不动的复制到新数组中，再把指向原数组的地址换到新数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，ArrayList（int initialCapacity）不会初始化数组大小，因为它基于elementData数组而不是大小。</p>
<p>ArrayList的遍历性能比LinkedList快很多，因为ArrayList是内存连续的，CPU的内部缓存结构会缓存连续的内存片段，可以大幅降低读取内存的性能开销，所以ArrayList遍历性能好。</p>
</li>
</ol>
<h2 id="LinkedHashMap和TreeMap"><a href="#LinkedHashMap和TreeMap" class="headerlink" title="LinkedHashMap和TreeMap"></a>LinkedHashMap和TreeMap</h2><p>LinkedHashMap内部维护了一个双向链表，保存了记录的插入顺序，因此可以按照插入的顺序从头部或者尾部迭代；</p>
<p>因为TreeMap实现了SortMap接口，将保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器。当用Iterator遍历TreeMap时，得到的记录是排过序的。TreeMap基于红黑树实现，非线程安全。</p>
<p>TreeMap()：构建一个空的映像树；</p>
<p>TreeMap(Map m)：构建一个映像树，并且添加映像m中所有元素；</p>
<p>TreeMap(Comparator c)：构建一个映像树，并且使用特定的比较器对关键字进行排序；</p>
<p>TreeMap(SortedMap s)：构建一个映像树，添加映像树s中所有映射，并且使用与有序映像s相同的比较器排序；</p>
<h2 id="hashcode-和equals"><a href="#hashcode-和equals" class="headerlink" title="hashcode()和equals()"></a>hashcode()和equals()</h2><p>==：比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。</p>
<p>equals()：是对两个对象的地址值进行的比较（即比较引用是否相同）。但是String 、Math、Integer、Double等这些封装类在使用equals()方法时，已经覆盖了object类的equals()方法，从而进行的是内容的比较。当然，基本类型是进行值的比较。</p>
<p>它的性质有：</p>
<ul>
<li><strong>自反性</strong>（reflexive）。对于任意不为<code>null</code>的引用值x，<code>x.equals(x)</code>一定是<code>true</code>。</li>
<li><strong>对称性</strong>（symmetric）。对于任意不为<code>null</code>的引用值<code>x</code>和<code>y</code>，当且仅当<code>x.equals(y)</code>是<code>true</code>时，<code>y.equals(x)</code>也是<code>true</code>。</li>
<li><strong>传递性</strong>（transitive）。对于任意不为<code>null</code>的引用值<code>x</code>、<code>y</code>和<code>z</code>，如果<code>x.equals(y)</code>是<code>true</code>，同时<code>y.equals(z)</code>是<code>true</code>，那么<code>x.equals(z)</code>一定是<code>true</code>。</li>
<li><strong>一致性</strong>（consistent）。对于任意不为<code>null</code>的引用值<code>x</code>和<code>y</code>，如果用于equals比较的对象信息没有被修改的话，多次调用时<code>x.equals(y)</code>要么一致地返回<code>true</code>要么一致地返回<code>false</code>。</li>
<li>对于任意不为<code>null</code>的引用值<code>x</code>，<code>x.equals(null)</code>返回<code>false</code>。</li>
</ul>
<p>对于<code>Object</code>类来说，<code>equals()</code>方法在对象上实现的是差别可能性最大的等价关系，即，对于任意非<code>null</code>的引用值<code>x</code>和<code>y</code>，当且仅当<code>x</code>和<code>y</code>引用的是同一个对象，该方法才会返回<code>true</code>。</p>
<p><strong>需要注意的是当<code>equals()</code>方法被override时，<code>hashCode()</code>也要被override。按照一般<code>hashCode()</code>方法的实现来说，相等的对象，它们的hash code一定相等。</strong></p>
<p>hashcode()：<code>hashCode()</code>方法给对象返回一个hash code值。</p>
<p>Java对于eqauls方法和hashCode方法是这样规定的：     </p>
<p>  1.如果两个对象相同，那么它们的hashCode值一定要相同；</p>
<p>  2.如果两个对象的hashCode相同，它们并不一定相同（这里说的对象相同指的是用eqauls方法比较）。<br>    如不按要求去做了，会发现相同的对象可以出现在Set集合中，同时，增加新元素的效率会大大下降。<br>  3.equals()相等的两个对象，hashcode()一定相等；equals()不相等的两个对象，却并不能证明他们的hashcode()不相等。</p>
<p>​    换句话说，equals()方法不相等的两个对象，hashcode()有可能相等（我的理解是由于哈希码在生成的时候产生冲突造成的）。反过来，hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等。</p>
<h2 id="ConcurrentHashMap如何计算size"><a href="#ConcurrentHashMap如何计算size" class="headerlink" title="ConcurrentHashMap如何计算size"></a>ConcurrentHashMap如何计算size</h2><h2 id="使用Redis实现延迟消息队列"><a href="#使用Redis实现延迟消息队列" class="headerlink" title="使用Redis实现延迟消息队列"></a>使用Redis实现延迟消息队列</h2><p>zset</p>
<h2 id="为什么String是final的"><a href="#为什么String是final的" class="headerlink" title="为什么String是final的"></a>为什么String是final的</h2><blockquote>
<p>final关键字的好处：</p>
<p>提高了性能，JVM和Java应用都会缓存final变量；</p>
<p>final变量可以安全的在多线程环境下进行共享，不需要额外的同步开销；</p>
<p>使用final关键字，JVM会对方法，变量及类进行优化；</p>
</blockquote>
<ul>
<li>只有当字符串是不可变的，字符串池才有可能实现，字符串池在运行时节约很多堆空间；</li>
<li>线程安全；</li>
<li>因为字符串不可变，创建时hashcode被缓存，不需要重新计算，使得字符串很适合作为Map的key；</li>
</ul>
<h2 id="count-和-count-1-和count-列名-区别"><a href="#count-和-count-1-和count-列名-区别" class="headerlink" title="count(*) 和 count(1)和count(列名)区别"></a>count(*) 和 count(1)和count(列名)区别</h2><p>count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL；</p>
<p>count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL；</p>
<p>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计；</p>
<p><strong>执行效率上：</strong></p>
<p>列名为主键，count(列名)会比count(1)快 ；<br>列名不为主键，count(1)会比count(列名)快；<br>如果表多个列并且没有主键，则 count（1） 的执行效率优于 count(*)；</p>
<p>如果有主键，则 select count（主键）的执行效率是最优的 ；<br>如果表只有一个字段，则 select count（*）最优；</p>
<h2 id="Springboot启动流程"><a href="#Springboot启动流程" class="headerlink" title="Springboot启动流程"></a>Springboot启动流程</h2><p>@SpringBootApplication包括三个注解，功能如下：</p>
<p>@EnableAutoConfiguration：SpringBoot根据应用所声明的依赖来对Spring框架进行自动配置；</p>
<p>@SpringBootConfiguration(内部为@Configuration)：被标注的类等于在spring的XML配置文件中(applicationContext.xml)，装配所有bean事务，提供了一个spring的上下文环境；</p>
<p>@ComponentScan：组件扫描，可自动发现和装配Bean，默认扫描SpringApplication的run方法里的Booter.class所在的包路径下文件，所以最好将该启动类放到根包路径下；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">        Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        configureHeadlessProperty();</span><br><span class="line"><span class="comment">//1.通过SpringFactoriesLoader查找并加载所有的SpringApplicationRunListeners，通过调用</span></span><br><span class="line"><span class="comment">//starting()方法通知所有的SpringApplicationRunListeners：应用开始启动了</span></span><br><span class="line">        SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">        listeners.starting();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//2.创建并配置当前应用将要使用的Environment</span></span><br><span class="line">            ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">                    args);</span><br><span class="line">            ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">                    applicationArguments);</span><br><span class="line">            configureIgnoreBeanInfo(environment);</span><br><span class="line"><span class="comment">//3.打印banner</span></span><br><span class="line">            Banner printedBanner = printBanner(environment);</span><br><span class="line"><span class="comment">//4.根据是否是web项目，来创建不同的ApplicationContext容器</span></span><br><span class="line">            context = createApplicationContext();</span><br><span class="line"><span class="comment">//5.创建一系列FailureAnalyzer</span></span><br><span class="line">            exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">                    SpringBootExceptionReporter.class,</span><br><span class="line">                    <span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line"><span class="comment">//6.初始化ApplicationContext</span></span><br><span class="line">            prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">                    printedBanner);</span><br><span class="line"><span class="comment">//7.调用ApplicationContext的refresh()方法,刷新容器</span></span><br><span class="line">            refreshContext(context);</span><br><span class="line"><span class="comment">//8.查找当前context中是否注册有CommandLineRunner和ApplicationRunner，如果有则遍历执行它们。</span></span><br><span class="line">            afterRefresh(context, applicationArguments);</span><br><span class="line">            stopWatch.stop();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">                <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">                        .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">            &#125;</span><br><span class="line">            listeners.started(context);</span><br><span class="line">            callRunners(context, applicationArguments);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            handleRunFailure(context, listeners, exceptionReporters, ex);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        listeners.running(context);</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>1.通过SpringFactoriesLoader查找并加载所有的SpringApplicationRunListeners，通过调用starting()方法通知所有的SpringApplicationRunListeners：应用开始启动了。（SpringApplicationRunListeners其本质上就是一个事件发布者，它在SpringBoot应用启动的不同时间点发布不同应用事件类型(ApplicationEvent)，如果有哪些事件监听者(ApplicationListener)对这些事件感兴趣，则可以接收并且处理）<br> 看下SpringApplicationRunListeners源码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">SpringApplicationRunListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行run方法时立即调用此方法，可以用户非常早期的初始化工作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">starting</span>(<span class="params"></span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Environment准备好后，并且ApplicationContext创建之前调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">environmentPrepared</span>(<span class="params">ConfigurableEnvironment environment</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ApplicationContext创建好后立即调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextPrepared</span>(<span class="params">ConfigurableApplicationContext context</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ApplicationContext加载完成，在refresh之前调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoaded</span>(<span class="params">ConfigurableApplicationContext context</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当run方法结束之前调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finished</span>(<span class="params">ConfigurableApplicationContext context, Throwable exception</span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringApplicationRunListener只有一个实现类：EventPublishingRunListener。①处的代码只会获取到一个EventPublishingRunListener的实例，我们来看看starting()方法的内容：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 发布一个ApplicationStartedEvent</span></span><br><span class="line">    <span class="keyword">this</span>.initialMulticaster.multicastEvent(<span class="keyword">new</span> ApplicationStartedEvent(<span class="keyword">this</span>.application, <span class="keyword">this</span>.args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.创建并配置当前应用将要使用的Environment，Environment用于描述应用程序当前的运行环境，其抽象了两个方面的内容：配置文件(profile)和属性(properties)，不同的环境(eg：生产环境、预发布环境)可以使用不同的配置文件，而属性则可以从配置文件、环境变量、命令行参数等来源获取。因此，当Environment准备好后，在整个应用的任何时候，都可以从Environment中获取资源。</p>
<blockquote>
<ul>
<li>判断Environment是否存在，不存在就创建（如果是web项目就创建StandardServletEnvironment，否则创建StandardEnvironment）</li>
<li>配置Environment：配置profile以及properties</li>
<li>调用SpringApplicationRunListener的environmentPrepared()方法，通知事件监听者：应用的Environment已经准备好</li>
</ul>
</blockquote>
<p>3.打印banner（可以自定义）<br>4.根据是否是web项目，来创建不同的ApplicationContext容器<br>5.创建一系列FailureAnalyzer，创建流程依然是通过SpringFactoriesLoader获取到所有实现FailureAnalyzer接口的class，然后在创建对应的实例。FailureAnalyzer用于分析故障并提供相关诊断信息。<br> 6.初始化ApplicationContext</p>
<ul>
<li>将准备好的Environment设置给ApplicationContext</li>
<li>遍历调用所有的ApplicationContextInitializer的initialize()方法来对已经创建好的ApplicationContext进行进一步的处理</li>
<li>调用SpringApplicationRunListener的contextPrepared()方法，通知所有的监听者：ApplicationContext已经准备完毕</li>
<li>将所有的bean加载到容器中</li>
<li>调用SpringApplicationRunListener的contextLoaded()方法，通知所有的监听者：ApplicationContext已经装载完毕</li>
</ul>
<p>7.调用ApplicationContext的refresh()方法,刷新容器</p>
<ul>
<li>这里的刷新和spring中刷新原理类似，这里重点关注invokeBeanFactoryPostProcessors(beanFactory);方法，主要完成获取到所有的BeanFactoryPostProcessor来对容器做一些额外的操作，通过源可以进入到PostProcessorRegistrationDelegate类<br> 的invokeBeanFactoryPostProcessors()方法，会获取类型为BeanDefinitionRegistryPostProcessor的beanorg.springframework.context.annotation.internalConfigurationAnnotationProcessor，对应的Class为ConfigurationClassPostProcessor。ConfigurationClassPostProcessor用于解析处理各种注解，包括：@Configuration、@ComponentScan、@Import、@PropertySource、@ImportResource、@Bean。当处理@import注解的时候，就会调用&lt;自动配置&gt;这一小节中的EnableAutoConfigurationImportSelector.selectImports()来完成自动配置功能</li>
</ul>
<p>8.查找当前context中是否注册有CommandLineRunner和ApplicationRunner，如果有则遍历执行它们。</p>
<h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><p>接口：</p>
<p>因为java不支持多重继承，所以有了接口，一个类只能继承一个父类，但可以实现多个接口，接口本身也可以继承多个接口。</p>
<p>接口里面的成员变量默认都是public static final类型的，必须被显示的初始化；接口里面的方法默认都是public abstract类型的，隐式声明；</p>
<p>接口没有构造方法，不能被实例化；</p>
<p>类如果实现了一个接口，那么必须实现接口里面的所有抽象方法，否则类要被定义为抽象类；</p>
<p>抽象类：</p>
<p>如果将一个类声明为abstract，此类不能生成对象，只能被继承使用；</p>
<p>抽象方法必须存在于抽象类中，抽象类中可以有一般的变量和一般的方法；</p>
<p>子类继承抽象类必须实现其中抽象方法，除非子类为抽象类；<br> private void print(){}；此语句表示方法的空实现。<br> abstract void print()； 此语句表示方法的抽象，无实现。</p>
<p><strong>区别：</strong></p>
<p>接口只能包含抽象方法，抽象类可以包含普通方法；</p>
<p>接口只能定义静态常量属性，抽象类既可以定义普通属性，也可以定义静态常量属性；</p>
<p>接口不包含构造方法，抽象类里可以包含构造方法；</p>
<p>抽象类中可以包含静态方法，接口中不能包含静态方法；</p>
<h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><p>一个分布式系统<strong>不可能同时满足</strong>一致性（ <code>C:Consistency</code> )，可用性（ <code>A: Availability</code> ）和分区容错性（ <code>P：Partition tolerance</code> ）这三个基本需求，<strong>最多只能同时满足其中的 2 个</strong>。</p>
<p>如下：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>C(Consistence)</code></td>
<td><strong>一致性</strong>，指数据在多个副本之间能够保持一致的特性（<strong>严格的一致性</strong>）。</td>
</tr>
<tr>
<td><code>A(Availability)</code></td>
<td><strong>可用性</strong>，指系统提供的服务必须一直处于可用的状态，每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据。</td>
</tr>
<tr>
<td><code>P(Network partitioning)</code></td>
<td><strong>分区容错性</strong>，分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障。</td>
</tr>
</tbody></table>
<p>分区：一个分布式系统，网络不通讯，导致连接不通，系统被分割成几个数据区域。</p>
<p>因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：<br>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。<br>CP - 满足一致性+分区 的系统，通常性能不是特别高。<br>AP - 满足可用性+分区 的系统，通常可能对一致性要求低一些。</p>
<h2 id="notify-和notifyAll-区别"><a href="#notify-和notifyAll-区别" class="headerlink" title="notify()和notifyAll()区别"></a>notify()和notifyAll()区别</h2><p>notify()只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现。</p>
<p>notifyAll 会唤醒所有等待(对象的)线程，哪一个线程将会第一个处理取决于操作系统的实现。</p>
<p>如果当前情况下有多个线程需要被唤醒，推荐使用notifyAll 方法。比如在生产者-消费者里面的使用，每次都需要唤醒所有的消费者或是生产者，以判断程序是否可以继续往下执行。</p>
<h2 id="sleep-和wait-区别"><a href="#sleep-和wait-区别" class="headerlink" title="sleep()和wait()区别"></a>sleep()和wait()区别</h2><ul>
<li>sleep() 是 Thread 类的静态本地方法；wait() 是Object类的成员本地方法</li>
<li>sleep() 方法可以在任何地方使用；wait() 方法则只能在同步方法或同步代码块中使用，否则抛出异常Exception in thread “Thread-0” java.lang.IllegalMonitorStateException</li>
<li>sleep() 会休眠当前线程指定时间，释放 CPU 资源，不释放对象锁，休眠时间到自动苏醒继续执行；wait() 方法放弃持有的对象锁，进入等待队列，当该对象被调用 notify() / notifyAll() 方法后才有机会竞争获取对象锁，进入运行状态</li>
<li>JDK1.8 sleep() wait() 均需要捕获 InterruptedException 异常</li>
</ul>
<h2 id="Thread类中interrupt（）、interrupted（）和isInterrupted（）方法详解"><a href="#Thread类中interrupt（）、interrupted（）和isInterrupted（）方法详解" class="headerlink" title="Thread类中interrupt（）、interrupted（）和isInterrupted（）方法详解"></a>Thread类中interrupt（）、interrupted（）和isInterrupted（）方法详解</h2><p>interrupt()：其作用是中断此线程（此线程不一定是当前线程，而是指调用该方法的Thread实例所代表的线程），但实际上只是给线程设置一个中断标志，线程仍会继续运行。</p>
<p>interrupted()：作用是测试当前线程是否被中断（检查中断标志），返回一个boolean并清除中断状态，第二次再调用时中断状态已经被清除，将返回一个false。</p>
<p>isInterrupted()：作用是只测试此线程是否被中断 ，不清除中断状态。</p>
<h2 id="Transactional实现原理"><a href="#Transactional实现原理" class="headerlink" title="@Transactional实现原理"></a>@Transactional实现原理</h2><h2 id="OOP的理解"><a href="#OOP的理解" class="headerlink" title="OOP的理解"></a>OOP的理解</h2><p>OOP是面向对象编程，特征是封装、继承、多态、抽象。<br>封装：是指将对象信息状态通过访问权限修饰符隐藏在对象内部，不允许外部程序直接访问，如果外部程序要访问对象内部，可以调用内部提供的get或set方法。简单来说，封装就是要找出某一类事务的公性然后提取出来。<br>继承：子类继承了父类所有的成员方法和属性，并且可以拥有自己特性。继承解决了代码的重用问题；<br>多态：多态存在的三个条件1.继承2.重写3.父类引用指向子类对象<br>多态的实现方式：接口实现，继承父类方法重写，同一个类中进行重载；<br>重载：多个同名函数同时存在，具有不同的参数个数/类型，返回值类型可以相同可以不同，调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性，存在于父类和子类、同类中；<br>重写：</p>
<p>​    1.参数列表必须完全与被重写的方法相同；<br>​    2.返回的类型必须一直与被重写的方法的返回类型相同；<br>​    3.访问修饰符的限制一定要大于被重写方法的访问修饰符；<br>​    4.重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常；<br>​    5.存在于父类和子类之间，方法被定义为final不能被重写；<br>抽象：如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。<br>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。</p>
<h2 id="集合的基类"><a href="#集合的基类" class="headerlink" title="集合的基类"></a>集合的基类</h2><h2 id="子类继承父类的初始化顺序"><a href="#子类继承父类的初始化顺序" class="headerlink" title="子类继承父类的初始化顺序"></a>子类继承父类的初始化顺序</h2><ol>
<li>父类的静态成员变量</li>
<li>父类的静态代码块</li>
<li>子类的静态成员变量</li>
<li>子类的静态代码块</li>
<li>父类的成员变量</li>
<li>父类的代码块</li>
<li>父类的构造函数</li>
<li>子类的成员变量</li>
<li>子类的代码块</li>
<li>子类的构造函数</li>
</ol>
<h2 id="HTTP和TCP的区别和联系"><a href="#HTTP和TCP的区别和联系" class="headerlink" title="HTTP和TCP的区别和联系"></a>HTTP和TCP的区别和联系</h2><p>1、TCP连接</p>
<p>   手机能够使用联网功能是因为手机底层实现了TCP/IP协议，可以使手机终端通过无线网络建立TCP连接。TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在“无差别”的网络之上。</p>
<p>   建立起一个TCP连接需要经过“三次握手”：</p>
<p>   第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；</p>
<p>   第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>   第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
<p>   握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连 接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”（过程就不细写 了，就是服务器和客户端交互，最终确定断开）<br>2、HTTP连接</p>
<p>   HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。</p>
<p>   HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。</p>
<p>   1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。</p>
<p>   2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。</p>
<p>   由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的 做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客 户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。</p>
<p>二者的区别和联系：</p>
<p>TCP是底层通讯协议，定义的是数据传输和连接方式的规范；</p>
<p>HTTP是应用层协议，定义的是传输数据的内容的规范；</p>
<p>TCP是传输层，而http是应用层；</p>
<p>HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP也就一定支持TCP；</p>
<h2 id="二叉树-平衡二叉树-红黑树的区别"><a href="#二叉树-平衡二叉树-红黑树的区别" class="headerlink" title="二叉树 平衡二叉树 红黑树的区别"></a>二叉树 平衡二叉树 红黑树的区别</h2><p>二叉查找/搜索/排序树  BST  (binary search/sort tree)<br>（1）若它的左子树不空，则左子树上所有结点的值均小于它的根节点的值；<br>（2）若它的右子树上所有结点的值均大于它的根节点的值；<br>（3）它的左、右子树也分别为二叉排序树。</p>
<p>注意：对二叉查找树进行中序遍历，得到有序集合。</p>
<p>平衡二叉树（Self-balancing binary search tree）  自平衡二叉查找树，又被称为AVL树：<br>它是一 棵空树或它的左右两个子树的高度差(平衡因子)的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树，同时，平衡二叉树必定是二叉搜索树，反之则不一定。</p>
<p>红黑树<br>   R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种平衡二叉树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p>
<p>红黑树的特性:<br>（1）每个节点或者是黑色，或者是红色。<br>（2）根节点是黑色。<br>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]<br>（4）如果一个节点是红色的，则它的子节点必须是黑色的。<br>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css"></div><div class="article-licensing box"><div class="licensing-title"><p>JavaBasicProblem</p><p><a href="http://yoursite.com/2020/04/24/JavaBasicProblem/">http://yoursite.com/2020/04/24/JavaBasicProblem/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Jiayi Yang</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-04-24</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2020-09-21</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java/">Java</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/05/05/ComputerNetwork/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">ComputerNetwork</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/04/16/Lc-1115/"><span class="level-item">Lc-1115</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            appId: "EUMJSoVQNU9husSvEa2sjwgu-gzGzoHsz",
            appKey: "cIlIfJdKwlBAIbyYgLpDc1WT",
            
            avatar: "mm",
            
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            
            highlight: true,
            
            
            
            
            
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Java基本数据类型"><span class="level-left"><span class="level-item">1</span><span class="level-item">Java基本数据类型</span></span></a></li><li><a class="level is-mobile" href="#浏览器输入URL发生了什么"><span class="level-left"><span class="level-item">2</span><span class="level-item">浏览器输入URL发生了什么</span></span></a></li><li><a class="level is-mobile" href="#不论文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么IO操作还要分为字节流操作和字符流操作呢"><span class="level-left"><span class="level-item">3</span><span class="level-item">不论文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么IO操作还要分为字节流操作和字符流操作呢</span></span></a></li><li><a class="level is-mobile" href="#深拷贝和浅拷贝的区别"><span class="level-left"><span class="level-item">4</span><span class="level-item">深拷贝和浅拷贝的区别</span></span></a></li><li><a class="level is-mobile" href="#Spring-AOP的实现"><span class="level-left"><span class="level-item">5</span><span class="level-item">Spring AOP的实现</span></span></a></li><li><a class="level is-mobile" href="#ArrayList和LinkedList"><span class="level-left"><span class="level-item">6</span><span class="level-item">ArrayList和LinkedList</span></span></a></li><li><a class="level is-mobile" href="#LinkedHashMap和TreeMap"><span class="level-left"><span class="level-item">7</span><span class="level-item">LinkedHashMap和TreeMap</span></span></a></li><li><a class="level is-mobile" href="#hashcode-和equals"><span class="level-left"><span class="level-item">8</span><span class="level-item">hashcode()和equals()</span></span></a></li><li><a class="level is-mobile" href="#ConcurrentHashMap如何计算size"><span class="level-left"><span class="level-item">9</span><span class="level-item">ConcurrentHashMap如何计算size</span></span></a></li><li><a class="level is-mobile" href="#使用Redis实现延迟消息队列"><span class="level-left"><span class="level-item">10</span><span class="level-item">使用Redis实现延迟消息队列</span></span></a></li><li><a class="level is-mobile" href="#为什么String是final的"><span class="level-left"><span class="level-item">11</span><span class="level-item">为什么String是final的</span></span></a></li><li><a class="level is-mobile" href="#count-和-count-1-和count-列名-区别"><span class="level-left"><span class="level-item">12</span><span class="level-item">count(*) 和 count(1)和count(列名)区别</span></span></a></li><li><a class="level is-mobile" href="#Springboot启动流程"><span class="level-left"><span class="level-item">13</span><span class="level-item">Springboot启动流程</span></span></a></li><li><a class="level is-mobile" href="#抽象类和接口"><span class="level-left"><span class="level-item">14</span><span class="level-item">抽象类和接口</span></span></a></li><li><a class="level is-mobile" href="#CAP"><span class="level-left"><span class="level-item">15</span><span class="level-item">CAP</span></span></a></li><li><a class="level is-mobile" href="#notify-和notifyAll-区别"><span class="level-left"><span class="level-item">16</span><span class="level-item">notify()和notifyAll()区别</span></span></a></li><li><a class="level is-mobile" href="#sleep-和wait-区别"><span class="level-left"><span class="level-item">17</span><span class="level-item">sleep()和wait()区别</span></span></a></li><li><a class="level is-mobile" href="#Thread类中interrupt（）、interrupted（）和isInterrupted（）方法详解"><span class="level-left"><span class="level-item">18</span><span class="level-item">Thread类中interrupt（）、interrupted（）和isInterrupted（）方法详解</span></span></a></li><li><a class="level is-mobile" href="#Transactional实现原理"><span class="level-left"><span class="level-item">19</span><span class="level-item">@Transactional实现原理</span></span></a></li><li><a class="level is-mobile" href="#OOP的理解"><span class="level-left"><span class="level-item">20</span><span class="level-item">OOP的理解</span></span></a></li><li><a class="level is-mobile" href="#集合的基类"><span class="level-left"><span class="level-item">21</span><span class="level-item">集合的基类</span></span></a></li><li><a class="level is-mobile" href="#子类继承父类的初始化顺序"><span class="level-left"><span class="level-item">22</span><span class="level-item">子类继承父类的初始化顺序</span></span></a></li><li><a class="level is-mobile" href="#HTTP和TCP的区别和联系"><span class="level-left"><span class="level-item">23</span><span class="level-item">HTTP和TCP的区别和联系</span></span></a></li><li><a class="level is-mobile" href="#二叉树-平衡二叉树-红黑树的区别"><span class="level-left"><span class="level-item">24</span><span class="level-item">二叉树 平衡二叉树 红黑树的区别</span></span></a></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/2.png" alt="Jiayi Yang"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Jiayi Yang</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Hangzhou, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">51</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">18</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/JiayiY" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="level-start"><span class="level-item">分布式</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%89%91%E6%8C%87offer/"><span class="level-start"><span class="level-item">剑指offer</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B9%B6%E5%8F%91/"><span class="level-start"><span class="level-item">并发</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%A1%B9%E7%9B%AE/"><span class="level-start"><span class="level-item">项目</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-09-29T11:42:04.000Z">2020-09-29</time></p><p class="title"><a href="/2020/09/29/IMPROMPTU/">IMPROMPTU</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-09-27T04:56:57.000Z">2020-09-27</time></p><p class="title"><a href="/2020/09/27/spring-refresh/">spring_refresh</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-09-01T04:44:18.000Z">2020-09-01</time></p><p class="title"><a href="/2020/09/01/spring-ioc/">spring_ioc</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-08-25T05:07:41.000Z">2020-08-25</time></p><p class="title"><a href="/2020/08/25/Shiro/">Shiro</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-08-09T01:48:59.000Z">2020-08-09</time></p><p class="title"><a href="/2020/08/09/SeckillThinking/">SeckillThinking</a></p><p class="categories"><a href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Basis/"><span class="tag">Basis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Book/"><span class="tag">Book</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Database/"><span class="tag">Database</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Distribution/"><span class="tag">Distribution</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Dubbo/"><span class="tag">Dubbo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Framework/"><span class="tag">Framework</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JVM/"><span class="tag">JVM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Log/"><span class="tag">Log</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MQ/"><span class="tag">MQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySQL/"><span class="tag">MySQL</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Project/"><span class="tag">Project</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redis/"><span class="tag">Redis</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring/"><span class="tag">Spring</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/concurrent/"><span class="tag">concurrent</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dp/"><span class="tag">dp</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lc/"><span class="tag">lc</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lcof/"><span class="tag">lcof</span><span class="tag">16</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Blog of JiayiY" height="28"></a><p class="is-size-7"><span>&copy; 2020 Jiayi Yang</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>