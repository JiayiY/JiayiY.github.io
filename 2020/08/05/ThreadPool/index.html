<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="ThreadPool"><meta name="keywords" content="Java,concurrent"><meta name="author" content="Jiayi Yang"><meta name="copyright" content="Jiayi Yang"><title>ThreadPool | Blog of JiayiY</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"4U85N5WHN0","apiKey":"41907345c92be9403ed9f1eadef3f632","indexName":"dev_blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.2.0'
} </script><meta name="generator" content="Hexo 5.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.1.</span> <span class="toc-text">为什么使用线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.</span> <span class="toc-text">线程池状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">线程池的任务处理流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolExecutor%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E7%BA%BF%E7%A8%8B%E5%A4%8D%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">ThreadPoolExecutor如何做到线程复用的？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">2.</span> <span class="toc-text">阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF"><span class="toc-number">2.1.</span> <span class="toc-text">场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">操作方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">2.3.</span> <span class="toc-text">源码分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">常见问题</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i.bmp.ovh/imgs/2021/06/648ee42f65e461cd.jpg"></div><div class="author-info__name text-center">Jiayi Yang</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">55</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">18</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.bmp.ovh/imgs/2021/06/b914bf63a6c6a1d2.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Blog of JiayiY</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">ThreadPool</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-05</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%B9%B6%E5%8F%91/">并发</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="为什么使用线程池"><a href="#为什么使用线程池" class="headerlink" title="为什么使用线程池"></a>为什么使用线程池</h2><ul>
<li>创建/销毁线程需要消耗系统资源，线程池可以<strong>复用已创建的线程</strong>；</li>
<li>并发线程数量过多，可能会导致资源消耗过多，从而造成服务器崩溃，线程池可以统一管理线程，<strong>控制并发的数量</strong>（主要原因）；</li>
</ul>
<a id="more"></a>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="/2020/08/05/ThreadPool/1.png" alt="关系图"></p>
<ul>
<li><p>ThreadPoolExecutor</p>
<p>四种构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 五个参数的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 六个参数的构造函数-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 六个参数的构造函数-2</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 七个参数的构造函数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>int corePoolSize</strong>：该线程池中<strong>核心线程数最大值</strong>；</p>
<blockquote>
<p>核心线程：线程池中有两类线程，核心线程和非核心线程。核心线程默认情况下会一直存在于线程池中，即使这个核心线程什么都不干。</p>
</blockquote>
</li>
<li><p><strong>int maximumPoolSize</strong>：该线程池中<strong>线程总数最大值</strong>；</p>
</li>
<li><p><strong>long keepAliveTime</strong>：<strong>非核心线程闲置超时时长</strong>；</p>
<blockquote>
<p>非核心线程如果处于闲置状态超过该值，就会被销毁。如果设置allowCoreThreadTimeOut(true)，则会也作用于核心线程。</p>
</blockquote>
</li>
<li><p><strong>TimeUnit unit</strong>：keepAliveTime的单位。</p>
<blockquote>
<p>TimeUnit是一个枚举类型 ，包括以下属性：</p>
<p>NANOSECONDS ： 1微毫秒 = 1微秒 / 1000 </p>
<p>MICROSECONDS ： 1微秒 = 1毫秒 / 1000 </p>
<p>MILLISECONDS ： 1毫秒 = 1秒 /1000 </p>
<p>SECONDS ： 秒 </p>
<p>MINUTES ： 分</p>
<p>HOURS ： 小时 </p>
<p>DAYS ： 天</p>
</blockquote>
</li>
<li><p><strong>BlockingQueue workQueue</strong>：阻塞队列，维护着<strong>等待执行的Runnable任务对象</strong>；</p>
</li>
<li><p><strong>ThreadFactory threadFactory</strong>：创建线程的工厂，用于批量创建线程，统一在创建线程时设置一些参数，如是否守护线程、线程的优先级等。如果不指定，会新建一个默认的线程工厂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default thread factory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">        Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">&quot;pool-&quot;</span> + poolNumber.getAndIncrement() +</span><br><span class="line">            <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                              namePrefix + threadNumber.getAndIncrement(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>RejectedExecutionHandler handler</strong>：<strong>拒绝处理策略</strong>，线程数量大于最大线程数就会采用拒绝处理策略，四种：</p>
<blockquote>
<p><strong>ThreadPoolExecutor.AbortPolicy</strong>：<strong>默认拒绝处理策略</strong>，丢弃任务并抛出RejectedExecutionException异常；</p>
<p><strong>ThreadPoolExecutor.DiscardPolicy</strong>：丢弃新来的任务，但是不抛出异常；</p>
<p><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong>：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）；</p>
<p><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>：由调用线程处理该任务；</p>
</blockquote>
</li>
</ul>
<h2 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h2><p>线程池本身有一个调度线程，这个线程就是用于管理布控整个线程池里的各种任务和事务，例如创建线程、销毁线程、任务队列管理、线程队列管理等等，故线程池也有自己的状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The main pool control state, ctl, is an atomic integer packing</span></span><br><span class="line"><span class="comment"> * two conceptual fields</span></span><br><span class="line"><span class="comment"> *   workerCount, indicating the effective number of threads</span></span><br><span class="line"><span class="comment"> *   runState,    indicating whether running, shutting down etc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In order to pack them into one int, we limit workerCount to</span></span><br><span class="line"><span class="comment"> * (2^29)-1 (about 500 million) threads rather than (2^31)-1 (2</span></span><br><span class="line"><span class="comment"> * billion) otherwise representable. If this is ever an issue in</span></span><br><span class="line"><span class="comment"> * the future, the variable can be changed to be an AtomicLong,</span></span><br><span class="line"><span class="comment"> * and the shift/mask constants below adjusted. But until the need</span></span><br><span class="line"><span class="comment"> * arises, this code is a bit faster and simpler using an int.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The workerCount is the number of workers that have been</span></span><br><span class="line"><span class="comment"> * permitted to start and not permitted to stop.  The value may be</span></span><br><span class="line"><span class="comment"> * transiently different from the actual number of live threads,</span></span><br><span class="line"><span class="comment"> * for example when a ThreadFactory fails to create a thread when</span></span><br><span class="line"><span class="comment"> * asked, and when exiting threads are still performing</span></span><br><span class="line"><span class="comment"> * bookkeeping before terminating. The user-visible pool size is</span></span><br><span class="line"><span class="comment"> * reported as the current size of the workers set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The runState provides the main lifecycle control, taking on values:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   RUNNING:  Accept new tasks and process queued tasks</span></span><br><span class="line"><span class="comment"> *   SHUTDOWN: Don&#x27;t accept new tasks, but process queued tasks</span></span><br><span class="line"><span class="comment"> *   STOP:     Don&#x27;t accept new tasks, don&#x27;t process queued tasks,</span></span><br><span class="line"><span class="comment"> *             and interrupt in-progress tasks</span></span><br><span class="line"><span class="comment"> *   TIDYING:  All tasks have terminated, workerCount is zero,</span></span><br><span class="line"><span class="comment"> *             the thread transitioning to state TIDYING</span></span><br><span class="line"><span class="comment"> *             will run the terminated() hook method</span></span><br><span class="line"><span class="comment"> *   TERMINATED: terminated() has completed</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The numerical order among these values matters, to allow</span></span><br><span class="line"><span class="comment"> * ordered comparisons. The runState monotonically increases over</span></span><br><span class="line"><span class="comment"> * time, but need not hit each state. The transitions are:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RUNNING -&gt; SHUTDOWN</span></span><br><span class="line"><span class="comment"> *    On invocation of shutdown(), perhaps implicitly in finalize()</span></span><br><span class="line"><span class="comment"> * (RUNNING or SHUTDOWN) -&gt; STOP</span></span><br><span class="line"><span class="comment"> *    On invocation of shutdownNow()</span></span><br><span class="line"><span class="comment"> * SHUTDOWN -&gt; TIDYING</span></span><br><span class="line"><span class="comment"> *    When both queue and pool are empty</span></span><br><span class="line"><span class="comment"> * STOP -&gt; TIDYING</span></span><br><span class="line"><span class="comment"> *    When pool is empty</span></span><br><span class="line"><span class="comment"> * TIDYING -&gt; TERMINATED</span></span><br><span class="line"><span class="comment"> *    When the terminated() hook method has completed</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Threads waiting in awaitTermination() will return when the</span></span><br><span class="line"><span class="comment"> * state reaches TERMINATED.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Detecting the transition from SHUTDOWN to TIDYING is less</span></span><br><span class="line"><span class="comment"> * straightforward than you&#x27;d like because the queue may become</span></span><br><span class="line"><span class="comment"> * empty after non-empty and vice versa during SHUTDOWN state, but</span></span><br><span class="line"><span class="comment"> * we can only terminate if, after seeing that it is empty, we see</span></span><br><span class="line"><span class="comment"> * that workerCount is 0 (which sometimes entails a recheck -- see</span></span><br><span class="line"><span class="comment"> * below).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>线程池创建后处于<strong>RUNNING</strong>状态；</p>
</li>
<li><p>调用shutdown()方法后处于<strong>SHUTDOWN</strong>状态，线程池不能接受新的任务，清除一些空闲worker，会等待阻塞队列的任务完成；（SHUTDOWN：不接受新任务，但处理排队任务）</p>
</li>
<li><p>调用shutdownNow()方法后处于<strong>STOP</strong>状态，线程池不能接受新的任务，中断所有线程，阻塞队列中没有被执行的任务全部丢弃。此时，poolsize=0,阻塞队列的size也为0；（STOP：不接受新任务，也不处理排队任务，并中断正在执行的任务）</p>
</li>
<li><p>当所有的任务已终止，ctl记录的“任务数量”为0，线程池会变为<strong>TIDYING</strong>状态。接着会执行terminated()钩子方法；</p>
<blockquote>
<p>ThreadPoolExecutor中有一个控制状态的属性叫ctl，它是一个AtomicInteger类型的变量。</p>
</blockquote>
</li>
<li><p>线程池处在TIDYING状态时，<strong>执行完terminated()方法之后</strong>，就会由 <strong>TIDYING -&gt; TERMINATED</strong>， 线程池被设置为TERMINATED状态；</p>
</li>
</ul>
<h2 id="线程池的任务处理流程"><a href="#线程池的任务处理流程" class="headerlink" title="线程池的任务处理流程"></a>线程池的任务处理流程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK 1.8</span></span><br><span class="line"><span class="comment">// 执行命令，其中命令（下面称任务）对象是Runnable的实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断命令（任务）对象非空</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 获取ctl的值</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 判断如果当前工作线程数小于核心线程数，则创建新的核心线程并且执行传入的任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="comment">// 如果创建新的核心线程成功则直接返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 这里说明创建核心线程失败，需要更新ctl的临时变量c</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不小于corePoolSize，则将任务添加到workQueue队列。</span></span><br><span class="line">    <span class="comment">// 判断线程池是否处于运行中状态，同时尝试用非阻塞方法向任务队列放入任务（放入任务失败返回false）</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 这里是向任务队列投放任务成功，对线程池的运行中状态做二次检查</span></span><br><span class="line">        <span class="comment">// 如果线程池二次检查状态是非运行中状态，则从任务队列移除当前的任务调用拒绝策略处理之（也就是移除前面成功入队的任务实例）</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">// 调用拒绝策略处理任务 - 返回</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 线程池处于running状态，但是没有线程，则创建线程</span></span><br><span class="line">        <span class="comment">// 如果当前工作线程数量为0，则创建一个非核心线程并且传入的任务对象为null - 返回</span></span><br><span class="line">        <span class="comment">// 也就是创建的非核心线程不会马上运行，而是等待获取任务队列的任务去执行 </span></span><br><span class="line">        <span class="comment">// 如果前工作线程数量不为0，原来应该是最后的else分支，但是可以什么也不做，因为任务已经成功入队列，总会有合适的时机分配其他空闲线程去执行它</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 走到这里说明有以下的前提：</span></span><br><span class="line">    <span class="comment">// 0、线程池中的工作线程总数已经大于等于corePoolSize（简单来说就是核心线程已经全部懒创建完毕）</span></span><br><span class="line">    <span class="comment">// 1、线程池可能不是RUNNING状态</span></span><br><span class="line">    <span class="comment">// 2、线程池可能是RUNNING状态同时任务队列已经满了</span></span><br><span class="line">    <span class="comment">// 如果放入workQueue失败，则创建非核心线程执行任务，</span></span><br><span class="line">    <span class="comment">// 如果这时创建非核心线程失败(当前线程总数不小于maximumPoolSize时)，就会执行拒绝策略。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        <span class="comment">// 调用拒绝策略处理任务 - 返回</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么要二次检查线程池的状态?</strong></p>
<p>在多线程的环境下，线程池的状态是时刻发生变化的。很有可能刚获取线程池状态后线程池状态就改变了。判断是否将<code>command</code>加入<code>workqueue</code>是线程池之前的状态。倘若没有二次检查，万一线程池处于非<strong>RUNNING</strong>状态（在多线程环境下很有可能发生），那么<code>command</code>永远不会执行。</p>
<p>整体流程：</p>
<ol>
<li>线程总数量小于corePoolSize，无论线程是否空闲，都会直接创建核心线程执行任务（注意，这一步需要获得全局锁）；</li>
<li>线程总数量大于等于corePoolSize，判断线程池是否处于运行中状态，同时尝试用非阻塞方法向任务队列放入任务，这里会二次检查线程池运行状态，如果当前工作线程数量为0，则创建一个非核心线程并且传入的任务对象为null；</li>
<li>如果缓存队列满了，则会尝试创建非核心线程传入任务实例执行（注意这一步需要获得全局锁）；</li>
<li>如果创建非核心线程失败，此时需要拒绝执行任务，调用拒绝策略处理任务；</li>
</ol>
<h2 id="ThreadPoolExecutor如何做到线程复用的？"><a href="#ThreadPoolExecutor如何做到线程复用的？" class="headerlink" title="ThreadPoolExecutor如何做到线程复用的？"></a>ThreadPoolExecutor如何做到线程复用的？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks if a new worker can be added with respect to current</span></span><br><span class="line"><span class="comment">     * pool state and the given bound (either core or maximum). If so,</span></span><br><span class="line"><span class="comment">     * the worker count is adjusted accordingly, and, if possible, a</span></span><br><span class="line"><span class="comment">     * new worker is created and started, running firstTask as its</span></span><br><span class="line"><span class="comment">     * first task. This method returns false if the pool is stopped or</span></span><br><span class="line"><span class="comment">     * eligible to shut down. It also returns false if the thread</span></span><br><span class="line"><span class="comment">     * factory fails to create a thread when asked.  If the thread</span></span><br><span class="line"><span class="comment">     * creation fails, either due to the thread factory returning</span></span><br><span class="line"><span class="comment">     * null, or due to an exception (typically OutOfMemoryError in</span></span><br><span class="line"><span class="comment">     * Thread.start()), we roll back cleanly.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the task the new thread should run first (or</span></span><br><span class="line"><span class="comment">     * null if none). Workers are created with an initial first task</span></span><br><span class="line"><span class="comment">     * (in method execute()) to bypass queuing when there are fewer</span></span><br><span class="line"><span class="comment">     * than corePoolSize threads (in which case we always start one),</span></span><br><span class="line"><span class="comment">     * or when the queue is full (in which case we must bypass queue).</span></span><br><span class="line"><span class="comment">     * Initially idle threads are usually created via</span></span><br><span class="line"><span class="comment">     * prestartCoreThread or to replace other dying workers.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> core if true use corePoolSize as bound, else</span></span><br><span class="line"><span class="comment">     * maximumPoolSize. (A boolean indicator is used here rather than a</span></span><br><span class="line"><span class="comment">     * value to ensure reads of fresh values after checking other pool</span></span><br><span class="line"><span class="comment">     * state).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if successful</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个worker对象</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="comment">// 实例化一个Thread对象</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 线程池全局锁</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 启动这个线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>worker类部分源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Worker类部分源码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    Runnable firstTask;</span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其余代码略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Worker</code>类实现了<code>Runnable</code>接口，所以<code>Worker</code>也是一个线程任务。在构造方法中，创建了一个线程，线程的任务就是自己。故<code>addWorker</code>方法调用addWorker方法源码下半部分中的第4步<code>t.start</code>，会触发<code>Worker</code>类的<code>run</code>方法被JVM调用。</p>
</li>
</ul>
<ol start="3">
<li><p>常见的四种线程池</p>
<p>1）newCachedThreadPool：它是一个可以无限扩大的线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它比较适合处理执行时间比较短的任务；</p>
<p>corePoolSize为0，maxPoolSize为无限大，意味着线程数量可以无限大，keepAliveTime为60S，意味着线程空闲时间超过60S就会被回收；</p>
<p>采用SynchronousQueue装等待的任务，这个阻塞队列没有存储空间，这意味着只要有请求到来，就必须要找到一条工作线程处理他，如果当前没有空闲的线程，那么就会再创建一条新的线程；</p>
<p><strong>存在的问题</strong>：无界线程池，具有自动回收多余线程的功能。弊端在于第二个参数maxPoolSize被设置为Integer.MAX_VALUE，这可能会创建数量非常多的线程，甚至导致OOM。</p>
<p>2）newFixedThreadPool：它是一种固定大小的线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>corePoolSize和maxPoolSize都为用户设定的线程数量nThreads；</p>
<p>keepAliveTime为0，意味着一旦有多余的空闲线程，就会被立即停止掉；但这里keepAliveTime无效；</p>
<p>阻塞队列采用了LinkedBlockingQueue，它是一个无界队列，因此永远不可能拒绝任务；故如果核心线程空闲，则交给核心线程处理；如果核心线程不空闲，则入列等待，直到核心线程空闲。</p>
<p><strong>存在的问题</strong>：由于传入的LinkedBlockingQueue是没有容量上限的，所以当请求数越来越多，并且无法及时处理完毕的时候，即请求堆积的时候，会容易造成占用大量的内存，可能会导致OOM。</p>
<blockquote>
<p><strong>与CachedThreadPool的区别</strong>：</p>
<ul>
<li>因为 corePoolSize == maximumPoolSize ，所以FixedThreadPool只会创建核心线程。 而CachedThreadPool因为corePoolSize=0，所以只会创建非核心线程。</li>
<li>在 getTask() 方法，如果队列里没有任务可取，线程会一直阻塞在 LinkedBlockingQueue.take() ，线程不会被回收。 CachedThreadPool会在60s后收回。</li>
<li>由于线程不会被回收，会一直卡在阻塞，所以<strong>没有任务的情况下， FixedThreadPool占用资源更多</strong>。</li>
<li>都几乎不会触发拒绝策略，但是原理不同。FixedThreadPool是因为阻塞队列可以很大（最大为Integer最大值），故几乎不会触发拒绝策略；CachedThreadPool是因为线程池很大（最大为Integer最大值），几乎不会导致线程数量大于最大线程数，故几乎不会触发拒绝策略。</li>
</ul>
</blockquote>
<p>3）newSingleThreadExecutor：有且仅有一个核心线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有且仅有一个核心线程（corePoolSize = maximumPoolSize = 1），使用了LinkedBlockingQueue（容量很大），所以<strong>不会创建非核心线程</strong>。所有任务按照<strong>先来先执行</strong>的顺序执行。</p>
<p><strong>存在的问题</strong>：由于传入的LinkedBlockingQueue是没有容量上限的，所以如果这个唯一的线程不空闲，那么新来的任务会堆积在任务队列里等待执行，会容易造成占用大量的内存，可能会导致OOM。</p>
<p>4）newScheduledThreadPool：可调度的线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ScheduledThreadPoolExecutor():</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个定长线程池，支持定时及周期性任务执行。</p>
</li>
<li><p>线程池里的线程数量设定为多少比较合适？</p>
<ul>
<li>CPU密集型（加密，计算hash等）：最佳线程数为CPU核心数的1-2倍左右；</li>
</ul>
</li>
</ol>
<ul>
<li>耗时IO型（读写数据库、文件、网络读写等）：最佳线程数一般会大于CPU核心数很多倍，以JVM线程监控显示繁忙情况为依据，保证线程空闲可以衔接上。</li>
</ul>
<p>参考Brain Goetz推荐的计算方法；</p>
<p>线程数 = CPU核心数 * （1 + 平均等待时间 / 平均工作时间）</p>
<p>或者进行压测，根据压测结果确定线程数；</p>
<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>BlockingQueue一般用于生产者-消费者模式，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。<strong>BlockingQueue就是存放元素的容器</strong>。</p>
<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><table>
<thead>
<tr>
<th align="center">方法\处理方式</th>
<th align="center">抛出异常</th>
<th align="center">返回特殊值</th>
<th align="center">一直阻塞</th>
<th align="center">超时退出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入方法</td>
<td align="center">add(e)</td>
<td align="center">offer(e)</td>
<td align="center"><strong>put(e)</strong></td>
<td align="center">offer(e,time,unit)</td>
</tr>
<tr>
<td align="center">移除方法</td>
<td align="center">remove()</td>
<td align="center">poll()</td>
<td align="center"><strong>take()</strong></td>
<td align="center">poll(time,unit)</td>
</tr>
<tr>
<td align="center">检查方法</td>
<td align="center">element()</td>
<td align="center">peek()</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
</tbody></table>
<ul>
<li>抛出异常：如果试图的操作无法立即执行，抛异常。当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。</li>
<li>返回特殊值：如果试图的操作无法立即执行，返回一个特殊值，通常是true / false。</li>
<li>一直阻塞：如果试图的操作无法立即执行，则一直阻塞或者响应中断。</li>
<li>超时退出：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功，通常是 true / false。</li>
</ul>
<p><strong>注意之处</strong></p>
<ul>
<li>不能往阻塞队列中插入null,会抛出空指针异常。</li>
<li>可以访问阻塞队列中的任意元素，调用remove(o)可以将队列之中的特定对象移除，但并不高效，尽量避免使用。</li>
</ul>
<ol>
<li><p>实现类</p>
<p>1）ArrayBlockingQueue</p>
<p>有界阻塞队列，内部结构是数组，故具有数组的特性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span></span>&#123;</span><br><span class="line">    <span class="comment">//..省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以初始化队列大小， 且一旦初始化不能改变。构造方法中的fair表示控制对象的内部锁是否采用公平锁，默认是<strong>非公平锁</strong>。</p>
<p>2）LinkedBlockingQueue</p>
<p>有界阻塞队列，内部结构是链表，具有链表的特性。默认队列的大小是<code>Integer.MAX_VALUE</code>，也可以指定大小。此队列按照<strong>先进先出</strong>的原则对元素进行排序。</p>
<p>3）DelayQueue</p>
<p>DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。 </p>
<p>注入其中的元素必须实现 java.util.concurrent.Delayed 接口。该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。</p>
<p>4）PriorityBlockingQueue</p>
<p>基于优先级的无界阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），内部控制线程同步的锁采用的是公平锁。</p>
<blockquote>
<p>PriorityBlockingQueue不会阻塞数据生产者（因为队列是无界的），而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，<strong>生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。</strong>对于使用默认大小的<strong>LinkedBlockingQueue</strong>也是一样的。</p>
</blockquote>
<p>5）SynchronousQueue</p>
<p>这个队列比较特殊，<strong>没有任何内部容量</strong>，甚至连一个队列的容量都没有。并且每个<code>put</code>必须等待一个<code>take</code>，反之亦然。</p>
<p>需要区别容量为1的ArrayBlockingQueue、LinkedBlockingQueue。</p>
<p>以下方法的返回值，可以帮助理解这个队列：</p>
<ul>
<li>iterator() 永远返回空，因为里面没有东西；</li>
<li>peek() 永远返回null；</li>
<li>put() 往queue放进去一个element以后就一直wait直到有其他thread进来把这个element取走；</li>
<li>offer() 往queue里放一个element后立即返回，如果碰巧这个element被另一个thread取走了，offer方法返回true，认为offer成功；否则返回false；</li>
<li>take() 取出并且remove掉queue里的element，取不到东西他会一直等；</li>
<li>poll() 取出并且remove掉queue里的element，只有到碰巧另外一个线程正在往queue里offer数据或者put数据的时候，该方法才会取到东西。否则立即返回null；</li>
<li>isEmpty() 永远返回true；</li>
<li>remove()&amp;removeAll() 永远返回false；</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><ul>
<li><p>构造器</p>
<p>对同一个锁（lock）初始化了两个监视器，分别是notEmpty和notFull。这两个监视器的作用目前可以简单理解为标记分组，当该线程是put操作时，给他加上监视器notFull,标记这个线程是一个生产者；当线程是take操作时，给他加上监视器notEmpty，标记这个线程是消费者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据元素数组</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"><span class="comment">//下一个待取出元素索引</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"><span class="comment">//下一个待添加元素索引</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"><span class="comment">//元素个数</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">//内部锁</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="comment">//消费者监视器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="comment">//生产者监视器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//..省略其他代码</span></span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>put源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 1.自旋拿锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2.判断队列是否满了</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            <span class="comment">// 2.1如果满了，阻塞该线程，并标记为notFull线程，</span></span><br><span class="line">            <span class="comment">// 等待notFull的唤醒，唤醒之后继续执行while循环。</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        <span class="comment">// 3.如果没有满，则进入队列</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">// 4 唤醒一个等待的线程</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>所有执行put操作的线程竞争lock锁，拿到了lock锁的线程进入下一步，没有拿到lock锁的线程自旋竞争锁。</li>
<li>判断阻塞队列是否满了，如果满了，则调用await方法阻塞这个线程，并标记为notFull（生产者）线程，同时释放lock锁,等待被消费者线程唤醒。</li>
<li>如果没有满，则调用enqueue方法将元素put进阻塞队列。注意这一步的线程还有一种情况是第二步中阻塞的线程被唤醒且又拿到了lock锁的线程。</li>
<li>唤醒一个标记为notEmpty（消费者）的线程。</li>
</ol>
</li>
<li><p>take源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>take操作和put操作的流程是类似的，总结一下take操作的流程：</p>
<ol>
<li>所有执行take操作的线程竞争lock锁，拿到了lock锁的线程进入下一步，没有拿到lock锁的线程自旋竞争锁。</li>
<li>判断阻塞队列是否为空，如果是空，则调用await方法阻塞这个线程，并标记为notEmpty（消费者）线程，同时释放lock锁,等待被生产者线程唤醒。</li>
<li>如果没有空，则调用dequeue方法。注意这一步的线程还有一种情况是第二步中阻塞的线程被唤醒且又拿到了lock锁的线程。</li>
<li>唤醒一个标记为notFull（生产者）的线程。</li>
</ol>
</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li>生产者-消费者模式</li>
<li>线程池中</li>
</ul>
</li>
</ol>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><ol>
<li><p>submit和execute区别</p>
<ul>
<li>参数不一样</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line"><span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"><span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>execute()在Executor接口中定义的，在ThreadPoolExecutor中实现的；</p>
</li>
<li><p>execute会在运行期直接抛出异常，submit在调用Future.get时才会抛出异常；</p>
</li>
</ul>
</li>
<li><p>线程池如何保证当前线程获取池内的worker时不产生争用</p>
<p>worker实现了AQS，通过volatile修饰的state</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lock methods</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line"><span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css"></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Jiayi Yang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/08/05/ThreadPool/">http://yoursite.com/2020/08/05/ThreadPool/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/concurrent/">concurrent</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/08/06/ConcurrentHashMap/"><i class="fa fa-chevron-left">  </i><span>ConcurrentHashMap</span></a></div><div class="next-post pull-right"><a href="/2020/08/01/ThreadLocal/"><span>ThreadLocal</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.bmp.ovh/imgs/2021/06/b914bf63a6c6a1d2.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Jiayi Yang</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/algolia.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.3" zIndex="-2" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>