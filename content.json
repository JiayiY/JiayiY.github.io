{"pages":[],"posts":[{"title":"CAS","text":"","link":"/2020/07/14/CAS/"},{"title":"CopyOnWrite","text":"CopyOnWrite容器简介可以理解为写时复制的容器，当向容器中添加元素时，不是直接往容器中添加，而是将当前容器进行copy，复制出一个新的容器，然后向新容器中添加元素，最后将原容器的引用指向新容器。 好处：在并发的场景下对容器进行”读操作”而不需要”加锁”，从而达到读写分离的目的。 从JDK 1.5 开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器，分别是CopyOnWriteArrayList和CopyOnWriteArraySet。 CopyOnWriteArrayList优缺点分析优点：适用于读多写少的场景。在Java中遍历线程非安全的List时（如：ArrayList和 LinkedList），若中途有其他线程对List容器进行修改，那么会抛出ConcurrentModificationException异常。CopyOnWriteArrayList由于其“读写分离”，遍历和修改操作分别作用在不同的List容器，所以在使用迭代器遍历的时候，则不会抛出异常。 缺点：1）每次执行写操作都会将原容器拷贝一份，数据量大的时候，内存会存在较大的压力，可能会引起频繁Young GC和Full GC；2）只能保证最终数据一致性，不能保证实时一致性。 源码分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return {@code true} (as specified by {@link Collection#add}) */public boolean add(E e) { final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); int len = elements.length; // 拷贝原容器，长度加一 Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; // 将原容器引用指向新副本 setArray(newElements); return true; } finally { lock.unlock(); }}/** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). Returns the element that was removed from the list. * * @throws IndexOutOfBoundsException {@inheritDoc} */public E remove(int index) { final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); int len = elements.length; E oldValue = get(elements, index); int numMoved = len - index - 1; // 如果要删除的是列表末端数据，拷贝前len-1个数据到新副本上，再切换引用 if (numMoved == 0) setArray(Arrays.copyOf(elements, len - 1)); else { // 否则，将除要删除元素之外的其他元素拷贝到新副本中，并切换引用 Object[] newElements = new Object[len - 1]; System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index + 1, newElements, index, numMoved); setArray(newElements); } return oldValue; } finally { lock.unlock(); }}public E get(int index) { return get(getArray(), index);}","link":"/2020/07/17/CopyOnWrite/"},{"title":"HashMap","text":"源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187/** * Returns a power of two size for the given target capacity. */// 找到大于等于cap的2的幂的最小值static final int tableSizeFor(int cap) { int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;}// 扰动函数// 好处1 让高位数据与低位数据进行异或，加大低位信息的随机性，变相的让高位数据参与到计算中// 好处2 增加hash的复杂度：覆写hashcode()时，可能会写出分布性不佳的方法，进而导致hash的冲突率比较高，此时通过移位和异或运算，可以让hash变得更加复杂，进而影响hash的分布性。// 以上是为什么hashmap不直接使用键对象原始hash的原因了static final int hash(Object key) { int h; // ^ ：按位异或 // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}public V put(K key, V value) { return putVal(hash(key), key, value, false, true);}/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 初始化桶数组 table，table 被延迟到插入新数据时再进行初始化 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 如果桶中不包含键值对节点引用，则将新键值对节点的引用存入桶中即可 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node&lt;K,V&gt; e; K k; // 如果键的值以及节点 hash 等于链表中的第一个键值对节点时，则将 e 指向该键值对 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 如果桶中的引用类型为 TreeNode，则调用红黑树的插入方法 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else { // 对链表进行遍历，并统计链表长度 for (int binCount = 0; ; ++binCount) { // 链表中不包含要插入的键值对节点时，则将该节点接在链表的最后 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); // 如果链表长度大于或等于树化阈值，则进行树化操作 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } // 条件为 true，表示当前链表包含要插入的键值对，终止遍历 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } // 判断要插入的键值对是否存在 HashMap 中 if (e != null) { // existing mapping for key V oldValue = e.value; // onlyIfAbsent 表示是否仅在 oldValue 为 null 的情况下更新键值对的值 if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; // 键值对数量超过阈值时，进行扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;}/** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */final Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; // 如果 table 不为空，表明已经初始化过了 if (oldCap &gt; 0) { // 当 table 容量超过容量最大值，则不再扩容 if (oldCap &gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } // 按旧容量和阈值的2倍计算新容量和阈值的大小 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold } // 初始化时，将threshold赋值给newCap，HashMap使用threshold变量暂时保存 initialCapacity的值 else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; // 调用无参构造方法时，桶数组容量为默认容量，阈值为默认容量与默认负载因子乘积 else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } // newThr 为 0 时，按阈值计算公式进行计算 if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; // 创建新的桶数组，桶数组的初始化也是在这里完成的 @SuppressWarnings({\"rawtypes\",\"unchecked\"}) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 如果旧的桶数组不为空，则遍历桶数组，并将键值对映射到新的桶数组中 if (oldTab != null) { for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; // 重新映射时，需要对红黑树进行拆分 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else { // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; // 遍历链表，并将链表节点按原顺序进行分组 do { next = e.next; if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); // 将分组后的链表映射到新桶中 if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab;} 流程总结put(K,V)插入操作的入口方法是 put(K,V)，但核心逻辑在V putVal(int, K, V, boolean, boolean) 方法中。putVal()主要流程如下： 当桶数组 table 为空时，通过扩容的方式初始化 table； 查找要插入的键值对是否已经存在，存在的话根据条件判断是否用新值替换旧值； 如果不存在，则将键值对链入链表中，并根据链表长度决定是否将链表转为红黑树； 判断键值对数量是否大于阈值，大于的话则进行扩容操作；","link":"/2020/07/18/HashMap/"},{"title":"AQS","text":"AQS简介是AbstractQueuedSynchronizer的简称，是一个用来构建锁和同步器的框架，比如ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。 AQS源码分析内部数据结构它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待双端队列（多线程争用资源被阻塞时会进入此队列），并使用了两个指针head和tail用于标识队列的头部和尾部。 123456789101112131415161718192021222324252627282930313233343536373839/** * The synchronization state. */private volatile int state;/** * Returns the current value of synchronization state. * This operation has memory semantics of a {@code volatile} read. * @return current state value */protected final int getState() { return state;}/** * Sets the value of synchronization state. * This operation has memory semantics of a {@code volatile} write. * @param newState the new state value */protected final void setState(int newState) { state = newState;}/** * Atomically sets synchronization state to the given updated * value if the current state value equals the expected value. * This operation has memory semantics of a {@code volatile} read * and write. * * @param expect the expected value * @param update the new value * @return {@code true} if successful. False return indicates that the actual * value was not equal to the expected value. */protected final boolean compareAndSetState(int expect, int update) { // See below for intrinsics setup to support this return unsafe.compareAndSwapInt(this, stateOffset, expect, update);} CLH队列并不是直接存储线程，而是存储拥有线程的Node节点 Node的结构： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061static final class Node { // 标记一个结点（对应的线程）在共享模式下等待 static final Node SHARED = new Node(); // 标记一个结点（对应的线程）在独占模式下等待 static final Node EXCLUSIVE = null; // waitStatus的值，表示该结点（对应的线程）已被取消 static final int CANCELLED = 1; // waitStatus的值，表示后继结点（对应的线程）需要被唤醒 static final int SIGNAL = -1; // waitStatus的值，表示该结点（对应的线程）在等待某一条件 static final int CONDITION = -2; /*waitStatus的值，表示有资源可用，新head结点需要继续唤醒后继结点（共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。）*/ static final int PROPAGATE = -3; // 0:新结点入队时的默认状态 // 等待状态，取值范围，-3，-2，-1，0，1 volatile int waitStatus; volatile Node prev; // 前驱结点 volatile Node next; // 后继结点 volatile Thread thread; // 结点对应的线程 Node nextWaiter; // 等待队列里下一个等待条件的结点 // 判断共享模式的方法 final boolean isShared() { return nextWaiter == SHARED; } /** * Returns previous node, or throws NullPointerException if null. * Use when predecessor cannot be null. The null check could * be elided, but is present to help the VM. * * @return the predecessor of this node */ final Node predecessor() throws NullPointerException { Node p = prev; if (p == null) throw new NullPointerException(); else return p; } Node() { // Used to establish initial head or SHARED marker } Node(Thread thread, Node mode) { // Used by addWaiter this.nextWaiter = mode; this.thread = thread; } Node(Thread thread, int waitStatus) { // Used by Condition this.waitStatus = waitStatus; this.thread = thread; }} 资源共享模式资源有两种共享模式，或者说两种同步方式： 独占模式（Exclusive）：资源是独占的，一次只能一个线程获取。如ReentrantLock。 共享模式（Share）：同时可以被多个线程获取，具体的资源个数可以通过参数指定。如Semaphore/CountDownLatch。 不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法： isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。 tryAcquire(int)：独占模式。尝试获取资源，成功则返回true，失败则返回false。 tryRelease(int)：独占模式。尝试释放资源，成功则返回true，失败则返回false。 tryAcquireShared(int)：共享模式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 tryReleaseShared(int)：共享模式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。 这些方法虽然都是protected方法，但是它们并没有在AQS具体实现，而是直接抛出异常，因为AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现 123protected boolean tryAcquire(int arg) { throw new UnsupportedOperationException();} 这里没有定义成abstract的原因： 独占模式下只需要实现tryAcquire-tryRelease，而共享模式下只需要实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。 （一般情况下，子类只需要根据需求实现其中一种模式，当然也有同时实现两种模式的同步类，如ReadWriteLock。） 核心部分的源码分析 获取资源（独占） 123456789101112131415161718/** * Acquires in exclusive mode, ignoring interrupts. Implemented * by invoking at least once {@link #tryAcquire}, * returning on success. Otherwise the thread is queued, possibly * repeatedly blocking and unblocking, invoking {@link * #tryAcquire} until success. This method can be used * to implement method {@link Lock#lock}. * * @param arg the acquire argument. This value is conveyed to * {@link #tryAcquire} but is otherwise uninterpreted and * can represent anything you like. */// arg是要获取的资源的个数，在独占模式下始终为1。public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();} 函数流程如下： 1）tryAcquire()尝试直接去获取资源，如果成功则直接返回（这里体现了非公平锁，每个线程获取锁时会尝试直接抢占加塞一次，而CLH队列中可能还有别的线程在等待）； 2）addWaiter()将该线程加入等待队列的尾部，并标记为独占模式； 3）acquireQueued()使线程阻塞在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false； 4）如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166/** * Attempts to acquire in exclusive mode. This method should query * if the state of the object permits it to be acquired in the * exclusive mode, and if so to acquire it. * * &lt;p&gt;This method is always invoked by the thread performing * acquire. If this method reports failure, the acquire method * may queue the thread, if it is not already queued, until it is * signalled by a release from some other thread. This can be used * to implement method {@link Lock#tryLock()}. */// 尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。// 需自定义同步器去实现 tryLock()protected boolean tryAcquire(int arg) { throw new UnsupportedOperationException();}/** * Creates and enqueues node for current thread and given mode. * * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared * @return the new node */// 将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。private Node addWaiter(Node mode) { // 生成该线程对应的Node节点 Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure // 尝试快速方式直接放到队尾 Node pred = tail; if (pred != null) { node.prev = pred; // 使用CAS尝试，成功则返回 if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } // 如果等待队列为空或者上述CAS失败，通过自旋CAS插入（enq方法） enq(node); return node;}/** * Inserts node into queue, initializing if necessary. See picture above. * @param node the node to insert * @return node's predecessor */// 将node加入队尾private Node enq(final Node node) { // CAS自旋，直到成功加入队尾 for (;;) { Node t = tail; if (t == null) { // Must initialize // 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它。 if (compareAndSetHead(new Node())) tail = head; } else { //正常流程，放入队尾 node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } }}/** * Acquires in exclusive uninterruptible mode for thread already in * queue. Used by condition wait methods as well as acquire. * * @param node the node * @param arg the acquire argument * @return {@code true} if interrupted while waiting *//** * 1. 结点进入队尾后，检查状态，找到安全休息点； * 2. 调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己； * 3. 被唤醒后，看自己是否可以获取到资源。如果拿到，head指向当前结点，并返回从入队到获取到的整个过程中是否被中断过；如果没获取到，继续流程1。 */final boolean acquireQueued(final Node node, int arg) { // 标记是否成功拿到资源 boolean failed = true; try { // 标记等待过程中是否被中断过 boolean interrupted = false; // 自旋 for (;;) { // 获取前驱节点 final Node p = node.predecessor(); // 若前驱结点p是head，说明node是第二个结点，可以尝试去获取资源 if (p == head &amp;&amp; tryAcquire(arg)) { // 拿到资源后，将head指向该结点。 // 所以head所指的结点，就是当前获取到资源的那个结点或null。 setHead(node); // setHead中node.prev已置为null，此处再将head.next置为null，是为了方便GC回收以前的head结点。(意味着将之前拿完资源的结点出队) p.next = null; // help GC // 成功获取资源 failed = false; //返回等待过程中是否被中断过 return interrupted; } // 如果自己可以休息了，就进入waiting状态，直到被unpark() if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; } } finally { // 如果等待过程中没有成功获取资源（如timeout，或者可中断的情况下被中断了），那么取消结点在队列中的等待。 if (failed) cancelAcquire(node); }}/** * Checks and updates status for a node that failed to acquire. * Returns true if thread should block. This is the main signal * control in all acquire loops. Requires that pred == node.prev. * * @param pred node's predecessor holding status * @param node the node * @return {@code true} if thread should block */private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) { // 获取前驱节点状态 int ws = pred.waitStatus; if (ws == Node.SIGNAL) /* * This node has already set status asking a release * to signal it, so it can safely park. */ return true; if (ws &gt; 0) { /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ // 如果前驱放弃了，就一直往前找，直到找到一个正常等待状态的node，排在它的后面。 do { node.prev = pred = pred.prev; } while (pred.waitStatus &gt; 0); pred.next = node; } else { /* * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don't park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ // 如果前驱正常，就把前驱的状态设置成SIGNAL。 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); } return false;}/** * Convenience method to park and then check if interrupted * * @return {@code true} if interrupted */private final boolean parkAndCheckInterrupt() { // 调用park()使线程进入waiting状态 LockSupport.park(this); // 如果被唤醒，查看自己是不是被中断的。 return Thread.interrupted();} 注意： 队列的尾部插入新的Node节点：由于AQS中会存在多个线程同时争夺资源的情况，因此肯定会出现多个线程同时插入节点的操作，所以在这里是通过CAS自旋的方式保证了操作的线程安全性。（addWaiter()和enq()） park()会让当前线程进入waiting状态。在此状态下，有两种情况可以唤醒该线程：1）被unpark()；2）被interrupt()。 LockSupport类是Java 6 引入的，提供了基本的线程同步原语。LockSupport实际上是调用了Unsafe类里的函数，归结到Unsafe里，只有两个函数： park(boolean isAbsolute, long time)：阻塞当前线程 unpark(Thread jthread)：使给定的线程停止阻塞 所以结点进入等待队列后，是调用park使它进入阻塞状态的。只有头结点的线程是处于活跃状态的。 释放资源（独占） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * Releases in exclusive mode. Implemented by unblocking one or * more threads if {@link #tryRelease} returns true. * This method can be used to implement method {@link Lock#unlock}. * * @param arg the release argument. This value is conveyed to * {@link #tryRelease} but is otherwise uninterpreted and * can represent anything you like. * @return the value returned from {@link #tryRelease} */// 释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) // 唤醒等待队列里的下一个线程 unparkSuccessor(h); return true; } return false;}/** * Attempts to set the state to reflect a release in exclusive * mode. * * &lt;p&gt;This method is always invoked by the thread performing release. * */// 需要独占模式的自定义同步器去实现protected boolean tryRelease(int arg) { throw new UnsupportedOperationException();}/** * Wakes up node's successor, if one exists. * * @param node the node */private void unparkSuccessor(Node node) { /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ int ws = node.waitStatus; // 置零当前线程所在的节点状态，允许失败 if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ // 找到下一个需要唤醒的节点 Node s = node.next; // 如果这个后继结点为空或者状态大于0，即这个结点已被取消 if (s == null || s.waitStatus &gt; 0) { s = null; // 将等待队列中所有还有用的结点向前移动（从后向前找） for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; } if (s != null) // 唤醒 LockSupport.unpark(s.thread);} 获取资源（共享） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** * Acquires in shared mode, ignoring interrupts. Implemented by * first invoking at least once {@link #tryAcquireShared}, * returning on success. Otherwise the thread is queued, possibly * repeatedly blocking and unblocking, invoking {@link * #tryAcquireShared} until success. * * @param arg the acquire argument. This value is conveyed to * {@link #tryAcquireShared} but is otherwise uninterpreted * and can represent anything you like. */// 获取指定量的资源，获取成功则直接返回；获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。public final void acquireShared(int arg) { if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);}/** * Attempts to acquire in shared mode. This method should query if * the state of the object permits it to be acquired in the shared * mode, and if so to acquire it. * * &lt;p&gt;This method is always invoked by the thread performing * acquire. If this method reports failure, the acquire method * may queue the thread, if it is not already queued, until it is * signalled by a release from some other thread. * * &lt;p&gt;The default implementation throws {@link * UnsupportedOperationException}. */// 返回值：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。protected int tryAcquireShared(int arg) { throw new UnsupportedOperationException();}/** * Acquires in shared uninterruptible mode. * @param arg the acquire argument */// 将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，成功拿到相应量的资源后才返回。private void doAcquireShared(int arg) { // 加入队列尾部 final Node node = addWaiter(Node.SHARED); // 标记是否成功 boolean failed = true; try { // 标记等待过程中是否被中断过 boolean interrupted = false; for (;;) { // 获取前驱节点 final Node p = node.predecessor(); // 如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己 if (p == head) { // 尝试获取资源 int r = tryAcquireShared(arg); if (r &gt;= 0) { setHeadAndPropagate(node, r); p.next = null; // help GC // 如果等待过程中被打断过，此时将中断补上。 if (interrupted) selfInterrupt(); failed = false; return; } } // 判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt() if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); }}/** * Sets head of queue, and checks if successor may be waiting * in shared mode, if so propagating if either propagate &gt; 0 or * PROPAGATE status was set. * * @param node the node * @param propagate the return value from a tryAcquireShared */private void setHeadAndPropagate(Node node, int propagate) { Node h = head; // Record old head for check below setHead(node); /* * Try to signal next queued node if: * Propagation was indicated by caller, * or was recorded (as h.waitStatus either before * or after setHead) by a previous operation * (note: this uses sign-check of waitStatus because * PROPAGATE status may transition to SIGNAL.) * and * The next node is waiting in shared mode, * or we don't know, because it appears null * * The conservatism in both of these checks may cause * unnecessary wake-ups, but only when there are multiple * racing acquires/releases, so most need signals now or soon * anyway. */ // 如果还有剩余量，继续唤醒下一个邻居线程 if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) { Node s = node.next; if (s == null || s.isShared()) doReleaseShared(); }} 流程： 1）tryAcquireShared()尝试获取资源，成功则直接返回； 2）失败则通过doAcquireShared()进入等待队列park()，直到被unpark()/interrupt()并成功获取到资源才返回。整个等待过程也是忽略中断的。 释放资源（共享） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Releases in shared mode. Implemented by unblocking one or more * threads if {@link #tryReleaseShared} returns true. * * @param arg the release argument. This value is conveyed to * {@link #tryReleaseShared} but is otherwise uninterpreted * and can represent anything you like. * @return the value returned from {@link #tryReleaseShared} */// 释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。public final boolean releaseShared(int arg) { // 尝试释放资源 if (tryReleaseShared(arg)) { // 唤醒后继节点 doReleaseShared(); return true; } return false;}/** * Release action for shared mode -- signals successor and ensures * propagation. (Note: For exclusive mode, release just amounts * to calling unparkSuccessor of head if it needs signal.) */private void doReleaseShared() { /* * Ensure that a release propagates, even if there are other * in-progress acquires/releases. This proceeds in the usual * way of trying to unparkSuccessor of head if it needs * signal. But if it does not, status is set to PROPAGATE to * ensure that upon release, propagation continues. * Additionally, we must loop in case a new node is added * while we are doing this. Also, unlike other uses of * unparkSuccessor, we need to know if CAS to reset status * fails, if so rechecking. */ for (;;) { Node h = head; if (h != null &amp;&amp; h != tail) { int ws = h.waitStatus; if (ws == Node.SIGNAL) { if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases // 唤醒后继节点 unparkSuccessor(h); } else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS } if (h == head) // loop if head changed break; }} 其他 获取资源的方法除了acquire外，还有以下三个： acquireInterruptibly：申请可中断的资源（独占模式） acquireShared：申请共享模式的资源 acquireSharedInterruptibly：申请可中断的资源（共享模式）","link":"/2020/07/16/AQS/"},{"title":"Lc-1114","text":"Lc 1114.按序打印我们提供了一个类： public class Foo { public void one() { print(“one”); } public void two() { print(“two”); } public void three() { print(“three”); }}三个不同的线程将会共用一个 Foo 实例。 线程 A 将会调用 one() 方法线程 B 将会调用 two() 方法线程 C 将会调用 three() 方法请设计修改程序，以确保 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。 1234567891011121314151617181920212223242526272829303132333435363738class Foo { boolean firstFinished = false; boolean secondFinished = false; final Object obj = new Object(); public Foo() { } public void first(Runnable printFirst) throws InterruptedException { synchronized (obj) { // printFirst.run() outputs \"first\". Do not change or remove this line. printFirst.run(); firstFinished = true; } } public void second(Runnable printSecond) throws InterruptedException { synchronized (obj) { while (firstFinished) { // printSecond.run() outputs \"second\". Do not change or remove this line. printSecond.run(); secondFinished = true; } } } public void third(Runnable printThird) throws InterruptedException { synchronized (obj) { while (secondFinished) { // printThird.run() outputs \"third\". Do not change or remove this line. printThird.run(); } } }} 提交结果：超时 原因：while循环，不停抢占CPU资源来判断自身是否结束循环（自旋）。 优化使用wait+notify避免了自旋 1234567891011121314151617181920212223242526272829303132333435363738394041class Foo { final Object obj = new Object(); boolean firstFinished = false; boolean secondFinished = false; public Foo() { } public void first(Runnable printFirst) throws InterruptedException { synchronized (obj) { // printFirst.run() outputs \"first\". Do not change or remove this line. printFirst.run(); firstFinished = true; obj.notifyAll(); } } public void second(Runnable printSecond) throws InterruptedException { synchronized (obj) { while (!firstFinished) { obj.wait(); } // printSecond.run() outputs \"second\". Do not change or remove this line. printSecond.run(); secondFinished = true; obj.notifyAll(); } } public void third(Runnable printThird) throws InterruptedException { synchronized (obj) { while (!secondFinished) { obj.wait(); } // printThird.run() outputs \"third\". Do not change or remove this line. printThird.run(); } }} 优化：使用CountDownLatch（Semaphore同理） 1234567891011121314151617181920212223242526272829class Foo { CountDownLatch c2; CountDownLatch c3; public Foo() { c2 = new CountDownLatch(1); c3 = new CountDownLatch(1); } public void first(Runnable printFirst) throws InterruptedException { // printFirst.run() outputs \"first\". Do not change or remove this line. printFirst.run(); c2.countDown(); } public void second(Runnable printSecond) throws InterruptedException { c2.await(); // printSecond.run() outputs \"second\". Do not change or remove this line. printSecond.run(); c3.countDown(); } public void third(Runnable printThird) throws InterruptedException { c3.await(); // printThird.run() outputs \"third\". Do not change or remove this line. printThird.run(); }}","link":"/2020/07/13/Lc-1114/"},{"title":"Lcof09","text":"Lcof 09.用两个栈实现队列 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 1234567891011121314151617181920212223242526272829303132333435class CQueue { Stack in; Stack out; int size; public CQueue() { in = new Stack&lt;&gt;(); out = new Stack&lt;&gt;(); size=0; } public void appendTail(int value) { in.push(value); size++; } public int deleteHead() { if(size==0){ return -1; } if (out.isEmpty()) { while (!in.isEmpty()) { out.push(in.pop()); } } size--; return (int) out.pop(); }}/** * Your CQueue object will be instantiated and called as such: * CQueue obj = new CQueue(); * obj.appendTail(value); * int param_2 = obj.deleteHead(); */ 优化因为Stack继承了Vector接口，而Vector底层是一个Object[]数组，所以要考虑空间扩容和移位的问题。 可以使用LinkedList来做Stack的容器，其本身结构是个双向链表，扩容消耗少。 1234567891011121314151617181920212223class CQueue { LinkedList&lt;Integer&gt; stack1; LinkedList&lt;Integer&gt; stack2; public CQueue() { stack1 = new LinkedList&lt;&gt;(); stack2 = new LinkedList&lt;&gt;(); } public void appendTail(int value) { stack1.add(value); } public int deleteHead() { if (stack2.isEmpty()) { if (stack1.isEmpty()) return -1; while (!stack1.isEmpty()) { stack2.add(stack1.pop()); } return stack2.pop(); } else return stack2.pop(); }} 关系图","link":"/2020/06/27/Lcof09/"},{"title":"Lc-1115","text":"Lc 1115.交替打印FooBar我们提供一个类： 12345678910111213class FooBar { public void foo() { for (int i = 0; i &lt; n; i++) { print(\"foo\"); } } public void bar() { for (int i = 0; i &lt; n; i++) { print(\"bar\"); } }} 两个不同的线程将会共用一个 FooBar 实例。其中一个线程将会调用 foo() 方法，另一个线程将会调用 bar() 方法。 请设计修改程序，以确保 “foobar” 被输出 n 次。 12345678910111213141516171819202122232425262728293031323334353637383940class FooBar { private int n; private boolean isFooTurn = true; private Object obj = new Object(); public FooBar(int n) { this.n = n; } public void foo(Runnable printFoo) throws InterruptedException { for (int i = 0; i &lt; n; i++) { synchronized (obj){ if (!isFooTurn){ obj.wait(); } // printFoo.run() outputs \"foo\". Do not change or remove this line. printFoo.run(); isFooTurn = false; obj.notifyAll(); } } } public void bar(Runnable printBar) throws InterruptedException { for (int i = 0; i &lt; n; i++) { synchronized (obj){ if (isFooTurn){ obj.wait(); } // printBar.run() outputs \"bar\". Do not change or remove this line. printBar.run(); isFooTurn = true; obj.notifyAll(); } } }} 优化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class FooBar { private int n; private final Lock lock = new ReentrantLock(); private boolean allowedAProcess = true; private final Condition conditionA = lock.newCondition(); private final Condition conditionB = lock.newCondition(); public FooBar(int n) { this.n = n; } public void foo(Runnable printFoo) throws InterruptedException { for (int i = 0; i &lt; n; i++) { lock.lock(); try { while (!allowedAProcess) { conditionA.await(); } // printFoo.run() outputs \"foo\". Do not change or remove this line. printFoo.run(); allowedAProcess = false; conditionB.signalAll(); } finally { lock.unlock(); } } } public void bar(Runnable printBar) throws InterruptedException { for (int i = 0; i &lt; n; i++) { lock.lock(); try { while (allowedAProcess) { conditionB.await(); } // printBar.run() outputs \"bar\". Do not change or remove this line. printBar.run(); allowedAProcess = true; conditionA.signalAll(); } finally { lock.unlock(); } } }}","link":"/2020/07/16/Lc-1115/"},{"title":"Lcof10_1","text":"Lcof 10-1.斐波那契数列 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下： F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 1234567891011class Solution { public int fib(int n) { if (n == 0) { return 0; } else if (n == 1) { return 1; } else { return fib(n - 1) + fib(n - 2); } }} 提交结果：超时 原因： 大量重复的递归计算。 优化： 1234567891011class Solution { public int fib(int n) { int a = 0, b = 1, sum; for(int i = 0; i &lt; n; i++){ sum = (a + b) % 1000000007; a = b; b = sum; } return a; }}","link":"/2020/06/27/Lcof10-1/"},{"title":"VariousLock","text":"","link":"/2020/07/15/VariousLock/"},{"title":"SomeSynchronizationTool","text":"同步工具 类 作用 Semaphore 限制线程的数量 Exchanger 两个线程交换数据 CountDownLatch 线程等待直到计数器减为0时开始工作 CyclicBarrier 作用跟CountDownLatch类似，但是可以重复使用 Phaser 增强的CyclicBarrier Semaphore源码分析内部有一个继承了AQS的同步器Sync，重写了tryAcquireShared方法。在这个方法里，会去尝试获取资源。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Creates a {@code Semaphore} with the given number of * permits and nonfair fairness setting. * * @param permits the initial number of permits available. * This value may be negative, in which case releases * must occur before any acquires will be granted. */// 默认情况下使用非公平public Semaphore(int permits) { sync = new NonfairSync(permits);}/** * Creates a {@code Semaphore} with the given number of * permits and the given fairness setting. * * @param permits the initial number of permits available. * This value may be negative, in which case releases * must occur before any acquires will be granted. * @param fair {@code true} if this semaphore will guarantee * first-in first-out granting of permits under contention, * else {@code false} */public Semaphore(int permits, boolean fair) { sync = fair ? new FairSync(permits) : new NonfairSync(permits);}final int nonfairTryAcquireShared(int acquires) { for (;;) { int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; }}// 如果阻塞队列没有等待的线程，则参与许可的竞争；否则直接插入到阻塞队列尾节点并挂起，等待唤醒protected int tryAcquireShared(int acquires) { for (;;) { if (hasQueuedPredecessors()) return -1; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; }} demo12345678910111213141516171819202122232425262728293031public class SemaphoreDemo { static Semaphore semaphore = new Semaphore(5, true); public static void main(String[] args) { ExecutorService service = Executors.newFixedThreadPool(50); for (int i = 0; i &lt; 100; i++) { service.submit(new Task()); } service.shutdown(); } static class Task implements Runnable { @Override public void run() { try { semaphore.acquire(3); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"拿到了许可证\"); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"释放了许可证\"); semaphore.release(2); } }} 适用场景可以用来做流量分流，特别是对公共资源有限的场景； Exchanger用于两个线程交换数据，支持泛型。 源码分析使用park/unpark来实现等待状态的切换 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Waits for another thread to arrive at this exchange point (unless * the current thread is {@linkplain Thread#interrupt interrupted}), * and then transfers the given object to it, receiving its object * in return. * * &lt;p&gt;If another thread is already waiting at the exchange point then * it is resumed for thread scheduling purposes and receives the object * passed in by the current thread. The current thread returns immediately, * receiving the object passed to the exchange by that other thread. * * &lt;p&gt;If no other thread is already waiting at the exchange then the * current thread is disabled for thread scheduling purposes and lies * dormant until one of two things happens: * &lt;ul&gt; * &lt;li&gt;Some other thread enters the exchange; or * &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts} * the current thread. * &lt;/ul&gt; * &lt;p&gt;If the current thread: * &lt;ul&gt; * &lt;li&gt;has its interrupted status set on entry to this method; or * &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while waiting * for the exchange, * &lt;/ul&gt; * then {@link InterruptedException} is thrown and the current thread's * interrupted status is cleared. * * @param x the object to exchange * @return the object provided by the other thread * @throws InterruptedException if the current thread was * interrupted while waiting */@SuppressWarnings(\"unchecked\")public V exchange(V x) throws InterruptedException { Object v; Object item = (x == null) ? NULL_ITEM : x; // translate null args if ((arena != null || (v = slotExchange(item, false, 0L)) == null) &amp;&amp; ((Thread.interrupted() || // disambiguates null return (v = arenaExchange(item, false, 0L)) == null))) throw new InterruptedException(); return (v == NULL_ITEM) ? null : (V)v;}// 如果在指定时间内没有另一个线程调用exchange，会抛出超时异常。@SuppressWarnings(\"unchecked\")public V exchange(V x, long timeout, TimeUnit unit) throws InterruptedException, TimeoutException { Object v; Object item = (x == null) ? NULL_ITEM : x; long ns = unit.toNanos(timeout); if ((arena != null || (v = slotExchange(item, true, ns)) == null) &amp;&amp; ((Thread.interrupted() || (v = arenaExchange(item, true, ns)) == null))) throw new InterruptedException(); if (v == TIMED_OUT) throw new TimeoutException(); return (v == NULL_ITEM) ? null : (V)v;} demo1234567891011121314151617181920212223242526public class ExchangerDemo { public static void main(String[] args) throws InterruptedException { Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;(); new Thread(() -&gt; { try { System.out.println(\"这是线程A，得到了另一个线程的数据：\" + exchanger.exchange(\"这是来自线程A的数据\")); } catch (InterruptedException e) { e.printStackTrace(); } }).start(); System.out.println(\"这个时候线程A是阻塞的，在等待线程B的数据\"); Thread.sleep(1000); new Thread(() -&gt; { try { System.out.println(\"这是线程B，得到了另一个线程的数据：\" + exchanger.exchange(\"这是来自线程B的数据\")); } catch (InterruptedException e) { e.printStackTrace(); } }).start(); }} 适用场景一般用于两个线程之间更方便地在内存中交换数据，因为其支持泛型，所以可以传输任何的数据，比如IO流或者IO缓存。根据JDK中的注释，可总结如下： 此类提供对外的操作是同步的； 用于成对出现的线程之间交换数据； 可以视作双向的同步队列； 可应用于基因算法、流水线设计等场景； 当三个线程调用同一个实例的exchange方法时，只有前两个线程会交换数据，第三个线程会进入阻塞状态。 需要注意的是，exchange是可以重复使用的。也就是说。两个线程可以使用Exchanger在内存中不断地再交换数据。 CountDownLatchCountDownLatch用一个给定的计数器来初始化，该计数器的操作是原子操作，即同时只能有一个线程去操作该计数器。调用该类await()的线程会一直处于阻塞状态，直到其他线程调用countDown()使当前计数器的值变为零（每次调用countDown计数器的值减1）。当计数器值减至零时，所有因调用await()而处于等待状态的线程就会继续往下执行。这种现象只会出现一次，因为计数器不能被重置，如果业务上需要一个可以重置计数次数的版本，可以考虑使用CycliBarrier。 原理分析内部有一个继承了AQS的同步器Sync demo123456789101112131415161718192021222324252627282930313233343536/** * 描述： 模拟100米跑步，5名选手都准备好了，只等裁判员一声令下，所有人同时开始跑步。当所有人都到终点后，比赛结束。 */public class CountDownLatchDemo1And2 { public static void main(String[] args) throws InterruptedException { CountDownLatch begin = new CountDownLatch(1); CountDownLatch end = new CountDownLatch(5); ExecutorService service = Executors.newFixedThreadPool(5); for (int i = 0; i &lt; 5; i++) { final int no = i + 1; Runnable runnable = new Runnable() { @Override public void run() { System.out.println(\"No.\" + no + \"准备完毕，等待发令枪\"); try { begin.await(); System.out.println(\"No.\" + no + \"开始跑步了\"); Thread.sleep((long) (Math.random() * 10000)); System.out.println(\"No.\" + no + \"跑到终点了\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { end.countDown(); } } }; service.submit(runnable); } //裁判员检查发令枪... Thread.sleep(3000); System.out.println(\"发令枪响，比赛开始！\"); begin.countDown(); end.await(); System.out.println(\"所有人到达终点，比赛结束\"); }} 适用场景程序执行需要等待某个条件完成后才能继续执行后续的操作；如并行计算，当某个处理的运算量很大时，可以将该运算任务拆分成多个子任务，等待所有的子任务都完成之后，父任务再拿到所有子任务的运算结果进行汇总。 CyclicBarrier类似于CountDownLatch，它也是通过计数器来实现的。当某个线程调用await方法时，该线程进入等待状态，且计数器加1，当计数器的值达到设置的初始值时，所有因调用await进入等待状态的线程被唤醒，继续执行后续操作。因为CycliBarrier在释放等待线程后可以重用，所以称为循环barrier。CycliBarrier支持一个可选的Runnable，在计数器的值到达设定值后（但在释放所有线程之前），该Runnable运行一次，Runnable在每个屏障点只运行一个。 原理分析虽然功能与CountDownLatch类似，但是实现原理却完全不同，CyclicBarrier内部使用的是Lock + Condition实现的等待/通知模式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * Main barrier code, covering the various policies. */private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException,TimeoutException { final ReentrantLock lock = this.lock; lock.lock(); try { final Generation g = generation; if (g.broken) throw new BrokenBarrierException(); if (Thread.interrupted()) { breakBarrier(); throw new InterruptedException(); } int index = --count; if (index == 0) { // tripped boolean ranAction = false; try { final Runnable command = barrierCommand; if (command != null) command.run(); ranAction = true; nextGeneration(); return 0; } finally { if (!ranAction) breakBarrier(); } } // loop until tripped, broken, interrupted, or timed out for (;;) { try { if (!timed) trip.await(); else if (nanos &gt; 0L) nanos = trip.awaitNanos(nanos); } catch (InterruptedException ie) { if (g == generation &amp;&amp; ! g.broken) { breakBarrier(); throw ie; } else { // We're about to finish waiting even if we had not // been interrupted, so this interrupt is deemed to // \"belong\" to subsequent execution. Thread.currentThread().interrupt(); } } if (g.broken) throw new BrokenBarrierException(); if (g != generation) return index; if (timed &amp;&amp; nanos &lt;= 0L) { breakBarrier(); throw new TimeoutException(); } } } finally { lock.unlock(); }} demo123456789101112131415161718192021222324252627282930313233343536public class CyclicBarrierDemo { public static void main(String[] args) { CyclicBarrier cyclicBarrier = new CyclicBarrier(5, new Runnable() { @Override public void run() { System.out.println(\"所有人都到场了， 大家统一出发！\"); } }); for (int i = 0; i &lt; 10; i++) { new Thread(new Task(i, cyclicBarrier)).start(); } } static class Task implements Runnable { private int id; private CyclicBarrier cyclicBarrier; public Task(int id, CyclicBarrier cyclicBarrier) { this.id = id; this.cyclicBarrier = cyclicBarrier; } @Override public void run() { System.out.println(\"线程\" + id + \"现在前往集合地点\"); try { Thread.sleep((long) (Math.random() * 10000)); System.out.println(\"线程\" + id + \"到了集合地点，开始等待其他人到达\"); cyclicBarrier.await(); System.out.println(\"线程\" + id + \"出发了\"); } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } } }} Barrier被破坏如果线程在等待的过程中，Barrier被破坏，就会抛出BrokenBarrierException。可以用isBroken()方法检测Barrier是否被破坏。 如果有线程已经处于等待状态，调用reset方法会导致已经在等待的线程出现BrokenBarrierException异常。并且由于出现了BrokenBarrierException，将会导致始终无法等待； 如果在等待的过程中，线程被中断，也会抛出BrokenBarrierException异常，并且这个异常会传播到其他所有的线程； 如果在执行屏障操作过程中发生异常，则该异常将传播到当前线程中，其他线程会抛出BrokenBarrierException，屏障被损坏； 如果超出指定的等待时间，当前线程会抛出TimeoutException 异常，其他线程会抛出BrokenBarrierException异常； Phaser","link":"/2020/07/17/SomeSynchronizationTool/"},{"title":"ThreadPool","text":"线程池为什么使用线程池 创建/销毁线程需要消耗系统资源，线程池可以复用已创建的线程； 控制并发的数量。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因）； 可以对线程做统一管理； 原理 ThreadPoolExecutor 四种构造方法 12345678910111213141516171819202122232425262728293031// 五个参数的构造函数public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)// 六个参数的构造函数-1public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)// 六个参数的构造函数-2public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)// 七个参数的构造函数public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) int corePoolSize：该线程池中核心线程数最大值； 核心线程：线程池中有两类线程，核心线程和非核心线程。核心线程默认情况下会一直存在于线程池中，即使这个核心线程什么都不干。 int maximumPoolSize：该线程池中线程总数最大值； long keepAliveTime：非核心线程闲置超时时长； 非核心线程如果处于闲置状态超过该值，就会被销毁。如果设置allowCoreThreadTimeOut(true)，则会也作用于核心线程。 TimeUnit unit：keepAliveTime的单位。 TimeUnit是一个枚举类型 ，包括以下属性： NANOSECONDS ： 1微毫秒 = 1微秒 / 1000 MICROSECONDS ： 1微秒 = 1毫秒 / 1000 MILLISECONDS ： 1毫秒 = 1秒 /1000 SECONDS ： 秒 MINUTES ： 分 HOURS ： 小时 DAYS ： 天 BlockingQueue workQueue：阻塞队列，维护着等待执行的Runnable任务对象； ThreadFactory threadFactory：创建线程的工厂，用于批量创建线程，统一在创建线程时设置一些参数，如是否守护线程、线程的优先级等。如果不指定，会新建一个默认的线程工厂。 123456789101112131415161718192021222324252627/** * The default thread factory */static class DefaultThreadFactory implements ThreadFactory { private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; DefaultThreadFactory() { SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = \"pool-\" + poolNumber.getAndIncrement() + \"-thread-\"; } public Thread newThread(Runnable r) { Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); if (t.isDaemon()) t.setDaemon(false); if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; }} RejectedExecutionHandler handler：拒绝处理策略，线程数量大于最大线程数就会采用拒绝处理策略，四种： ThreadPoolExecutor.AbortPolicy：默认拒绝处理策略，丢弃任务并抛出RejectedExecutionException异常； ThreadPoolExecutor.DiscardPolicy：丢弃新来的任务，但是不抛出异常； ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）； ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务； 线程池状态线程池本身有一个调度线程，这个线程就是用于管理布控整个线程池里的各种任务和事务，例如创建线程、销毁线程、任务队列管理、线程队列管理等等，故线程池也有自己的状态。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * The main pool control state, ctl, is an atomic integer packing * two conceptual fields * workerCount, indicating the effective number of threads * runState, indicating whether running, shutting down etc * * In order to pack them into one int, we limit workerCount to * (2^29)-1 (about 500 million) threads rather than (2^31)-1 (2 * billion) otherwise representable. If this is ever an issue in * the future, the variable can be changed to be an AtomicLong, * and the shift/mask constants below adjusted. But until the need * arises, this code is a bit faster and simpler using an int. * * The workerCount is the number of workers that have been * permitted to start and not permitted to stop. The value may be * transiently different from the actual number of live threads, * for example when a ThreadFactory fails to create a thread when * asked, and when exiting threads are still performing * bookkeeping before terminating. The user-visible pool size is * reported as the current size of the workers set. * * The runState provides the main lifecycle control, taking on values: * * RUNNING: Accept new tasks and process queued tasks * SHUTDOWN: Don't accept new tasks, but process queued tasks * STOP: Don't accept new tasks, don't process queued tasks, * and interrupt in-progress tasks * TIDYING: All tasks have terminated, workerCount is zero, * the thread transitioning to state TIDYING * will run the terminated() hook method * TERMINATED: terminated() has completed * * The numerical order among these values matters, to allow * ordered comparisons. The runState monotonically increases over * time, but need not hit each state. The transitions are: * * RUNNING -&gt; SHUTDOWN * On invocation of shutdown(), perhaps implicitly in finalize() * (RUNNING or SHUTDOWN) -&gt; STOP * On invocation of shutdownNow() * SHUTDOWN -&gt; TIDYING * When both queue and pool are empty * STOP -&gt; TIDYING * When pool is empty * TIDYING -&gt; TERMINATED * When the terminated() hook method has completed * * Threads waiting in awaitTermination() will return when the * state reaches TERMINATED. * * Detecting the transition from SHUTDOWN to TIDYING is less * straightforward than you'd like because the queue may become * empty after non-empty and vice versa during SHUTDOWN state, but * we can only terminate if, after seeing that it is empty, we see * that workerCount is 0 (which sometimes entails a recheck -- see * below). */private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));private static final int COUNT_BITS = Integer.SIZE - 3;private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; // runState is stored in the high-order bitsprivate static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; 线程池创建后处于RUNNING状态； 调用shutdown()方法后处于SHUTDOWN状态，线程池不能接受新的任务，清除一些空闲worker，会等待阻塞队列的任务完成；（SHUTDOWN：不接受新任务，但处理排队任务） 调用shutdownNow()方法后处于STOP状态，线程池不能接受新的任务，中断所有线程，阻塞队列中没有被执行的任务全部丢弃。此时，poolsize=0,阻塞队列的size也为0；（STOP：不接受新任务，也不处理排队任务，并中断正在执行的任务） 当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。接着会执行terminated()钩子方法； ThreadPoolExecutor中有一个控制状态的属性叫ctl，它是一个AtomicInteger类型的变量。 线程池处在TIDYING状态时，执行完terminated()方法之后，就会由 TIDYING -&gt; TERMINATED， 线程池被设置为TERMINATED状态； 线程池的任务处理流程123456789101112131415161718192021222324252627282930313233343536373839404142// JDK 1.8// 执行命令，其中命令（下面称任务）对象是Runnable的实例public void execute(Runnable command) { // 判断命令（任务）对象非空 if (command == null) throw new NullPointerException(); // 获取ctl的值 int c = ctl.get(); // 判断如果当前工作线程数小于核心线程数，则创建新的核心线程并且执行传入的任务 if (workerCountOf(c) &lt; corePoolSize) { if (addWorker(command, true)) // 如果创建新的核心线程成功则直接返回 return; // 这里说明创建核心线程失败，需要更新ctl的临时变量c c = ctl.get(); } // 如果不小于corePoolSize，则将任务添加到workQueue队列。 // 判断线程池是否处于运行中状态，同时尝试用非阻塞方法向任务队列放入任务（放入任务失败返回false） if (isRunning(c) &amp;&amp; workQueue.offer(command)) { int recheck = ctl.get(); // 这里是向任务队列投放任务成功，对线程池的运行中状态做二次检查 // 如果线程池二次检查状态是非运行中状态，则从任务队列移除当前的任务调用拒绝策略处理之（也就是移除前面成功入队的任务实例） if (! isRunning(recheck) &amp;&amp; remove(command)) // 调用拒绝策略处理任务 - 返回 reject(command); // 线程池处于running状态，但是没有线程，则创建线程 // 如果当前工作线程数量为0，则创建一个非核心线程并且传入的任务对象为null - 返回 // 也就是创建的非核心线程不会马上运行，而是等待获取任务队列的任务去执行 // 如果前工作线程数量不为0，原来应该是最后的else分支，但是可以什么也不做，因为任务已经成功入队列，总会有合适的时机分配其他空闲线程去执行它 else if (workerCountOf(recheck) == 0) addWorker(null, false); } // 走到这里说明有以下的前提： // 0、线程池中的工作线程总数已经大于等于corePoolSize（简单来说就是核心线程已经全部懒创建完毕） // 1、线程池可能不是RUNNING状态 // 2、线程池可能是RUNNING状态同时任务队列已经满了 // 如果放入workQueue失败，则创建非核心线程执行任务， // 如果这时创建非核心线程失败(当前线程总数不小于maximumPoolSize时)，就会执行拒绝策略。 else if (!addWorker(command, false)) // 调用拒绝策略处理任务 - 返回 reject(command);} 为什么要二次检查线程池的状态? 在多线程的环境下，线程池的状态是时刻发生变化的。很有可能刚获取线程池状态后线程池状态就改变了。判断是否将command加入workqueue是线程池之前的状态。倘若没有二次检查，万一线程池处于非RUNNING状态（在多线程环境下很有可能发生），那么command永远不会执行。 整体流程： 线程总数量小于corePoolSize，无论线程是否空闲，都会直接创建核心线程执行任务（注意，这一步需要获得全局锁）； 线程总数量大于等于corePoolSize，判断线程池是否处于运行中状态，同时尝试用非阻塞方法向任务队列放入任务，这里会二次检查线程池运行状态，如果当前工作线程数量为0，则创建一个非核心线程并且传入的任务对象为null； 如果缓存队列满了，则会尝试创建非核心线程传入任务实例执行（注意这一步需要获得全局锁）； 如果创建非核心线程失败，此时需要拒绝执行任务，调用拒绝策略处理任务； ThreadPoolExecutor如何做到线程复用的？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * Checks if a new worker can be added with respect to current * pool state and the given bound (either core or maximum). If so, * the worker count is adjusted accordingly, and, if possible, a * new worker is created and started, running firstTask as its * first task. This method returns false if the pool is stopped or * eligible to shut down. It also returns false if the thread * factory fails to create a thread when asked. If the thread * creation fails, either due to the thread factory returning * null, or due to an exception (typically OutOfMemoryError in * Thread.start()), we roll back cleanly. * * @param firstTask the task the new thread should run first (or * null if none). Workers are created with an initial first task * (in method execute()) to bypass queuing when there are fewer * than corePoolSize threads (in which case we always start one), * or when the queue is full (in which case we must bypass queue). * Initially idle threads are usually created via * prestartCoreThread or to replace other dying workers. * * @param core if true use corePoolSize as bound, else * maximumPoolSize. (A boolean indicator is used here rather than a * value to ensure reads of fresh values after checking other pool * state). * @return true if successful */private boolean addWorker(Runnable firstTask, boolean core) { retry: for (;;) { int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) { int wc = workerCountOf(c); if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; // else CAS failed due to workerCount change; retry inner loop } } boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try { // 创建一个worker对象 w = new Worker(firstTask); // 实例化一个Thread对象 final Thread t = w.thread; if (t != null) { // 线程池全局锁 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) { if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; } } finally { mainLock.unlock(); } if (workerAdded) { // 启动这个线程 t.start(); workerStarted = true; } } } finally { if (! workerStarted) addWorkerFailed(w); } return workerStarted;} worker类部分源码： 12345678910111213141516// Worker类部分源码private final class Worker extends AbstractQueuedSynchronizer implements Runnable{ final Thread thread; Runnable firstTask; Worker(Runnable firstTask) { setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); } public void run() { runWorker(this); } //其余代码略...} Worker类实现了Runnable接口，所以Worker也是一个线程任务。在构造方法中，创建了一个线程，线程的任务就是自己。故addWorker方法调用addWorker方法源码下半部分中的第4步t.start，会触发Worker类的run方法被JVM调用。 常见的四种线程池 1）newCachedThreadPool：它是一个可以无限扩大的线程池 12345public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());} 它比较适合处理执行时间比较短的任务； corePoolSize为0，maxPoolSize为无限大，意味着线程数量可以无限大，keepAliveTime为60S，意味着线程空闲时间超过60S就会被回收； 采用SynchronousQueue装等待的任务，这个阻塞队列没有存储空间，这意味着只要有请求到来，就必须要找到一条工作线程处理他，如果当前没有空闲的线程，那么就会再创建一条新的线程； 存在的问题：无界线程池，具有自动回收多余线程的功能。弊端在于第二个参数maxPoolSize被设置为Integer.MAX_VALUE，这可能会创建数量非常多的线程，甚至导致OOM。 2）newFixedThreadPool：它是一种固定大小的线程池 12345public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());} corePoolSize和maxPoolSize都为用户设定的线程数量nThreads； keepAliveTime为0，意味着一旦有多余的空闲线程，就会被立即停止掉；但这里keepAliveTime无效； 阻塞队列采用了LinkedBlockingQueue，它是一个无界队列，因此永远不可能拒绝任务；故如果核心线程空闲，则交给核心线程处理；如果核心线程不空闲，则入列等待，直到核心线程空闲。 存在的问题：由于传入的LinkedBlockingQueue是没有容量上限的，所以当请求数越来越多，并且无法及时处理完毕的时候，即请求堆积的时候，会容易造成占用大量的内存，可能会导致OOM。 与CachedThreadPool的区别： 因为 corePoolSize == maximumPoolSize ，所以FixedThreadPool只会创建核心线程。 而CachedThreadPool因为corePoolSize=0，所以只会创建非核心线程。 在 getTask() 方法，如果队列里没有任务可取，线程会一直阻塞在 LinkedBlockingQueue.take() ，线程不会被回收。 CachedThreadPool会在60s后收回。 由于线程不会被回收，会一直卡在阻塞，所以没有任务的情况下， FixedThreadPool占用资源更多。 都几乎不会触发拒绝策略，但是原理不同。FixedThreadPool是因为阻塞队列可以很大（最大为Integer最大值），故几乎不会触发拒绝策略；CachedThreadPool是因为线程池很大（最大为Integer最大值），几乎不会导致线程数量大于最大线程数，故几乎不会触发拒绝策略。 3）newSingleThreadExecutor：有且仅有一个核心线程 123456public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));} 有且仅有一个核心线程（ corePoolSize == maximumPoolSize=1），使用了LinkedBlockingQueue（容量很大），所以，不会创建非核心线程。所有任务按照先来先执行的顺序执行。 存在的问题：由于传入的LinkedBlockingQueue是没有容量上限的，所以如果这个唯一的线程不空闲，那么新来的任务会堆积在任务队列里等待执行，会容易造成占用大量的内存，可能会导致OOM。 4）newScheduledThreadPool：可调度的线程池 12345678910public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize);}//ScheduledThreadPoolExecutor():public ScheduledThreadPoolExecutor(int corePoolSize) { super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue());} 创建一个定长线程池，支持定时及周期性任务执行。 线程池里的线程数量设定为多少比较合适？ CPU密集型（加密，计算hash等）：最佳线程数为CPU核心数的1-2倍左右； 耗时IO型（读写数据库、文件、网络读写等）：最佳线程数一般会大于CPU核心数很多倍，以JVM线程监控显示繁忙情况为依据，保证线程空闲可以衔接上。 参考Brain Goetz推荐的计算方法； 线程数 = CPU核心数 * （1 + 平均等待时间 / 平均工作时间） 或者进行压测，根据压测结果确定线程数； 阻塞队列场景BlockingQueue一般用于生产者-消费者模式，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。BlockingQueue就是存放元素的容器。 操作方法 方法\\处理方式 抛出异常 返回特殊值 一直阻塞 超时退出 插入方法 add(e) offer(e) put(e) offer(e,time,unit) 移除方法 remove() poll() take() poll(time,unit) 检查方法 element() peek() - - 抛出异常：如果试图的操作无法立即执行，抛异常。当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。 返回特殊值：如果试图的操作无法立即执行，返回一个特殊值，通常是true / false。 一直阻塞：如果试图的操作无法立即执行，则一直阻塞或者响应中断。 超时退出：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功，通常是 true / false。 注意之处 不能往阻塞队列中插入null,会抛出空指针异常。 可以访问阻塞队列中的任意元素，调用remove(o)可以将队列之中的特定对象移除，但并不高效，尽量避免使用。 实现类 1）ArrayBlockingQueue 有界阻塞队列，内部结构是数组，故具有数组的特性。 123public ArrayBlockingQueue(int capacity, boolean fair){ //..省略代码} 可以初始化队列大小， 且一旦初始化不能改变。构造方法中的fair表示控制对象的内部锁是否采用公平锁，默认是非公平锁。 2）LinkedBlockingQueue 有界阻塞队列，内部结构是链表，具有链表的特性。默认队列的大小是Integer.MAX_VALUE，也可以指定大小。此队列按照先进先出的原则对元素进行排序。 3）DelayQueue DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。 注入其中的元素必须实现 java.util.concurrent.Delayed 接口。该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。 4）PriorityBlockingQueue 基于优先级的无界阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），内部控制线程同步的锁采用的是公平锁。 PriorityBlockingQueue不会阻塞数据生产者（因为队列是无界的），而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。对于使用默认大小的LinkedBlockingQueue也是一样的。 5）SynchronousQueue 这个队列比较特殊，没有任何内部容量，甚至连一个队列的容量都没有。并且每个put必须等待一个take，反之亦然。 需要区别容量为1的ArrayBlockingQueue、LinkedBlockingQueue。 以下方法的返回值，可以帮助理解这个队列： iterator() 永远返回空，因为里面没有东西； peek() 永远返回null； put() 往queue放进去一个element以后就一直wait直到有其他thread进来把这个element取走； offer() 往queue里放一个element后立即返回，如果碰巧这个element被另一个thread取走了，offer方法返回true，认为offer成功；否则返回false； take() 取出并且remove掉queue里的element，取不到东西他会一直等； poll() 取出并且remove掉queue里的element，只有到碰巧另外一个线程正在往queue里offer数据或者put数据的时候，该方法才会取到东西。否则立即返回null； isEmpty() 永远返回true； remove()&amp;removeAll() 永远返回false； 源码分析 构造器 对同一个锁（lock）初始化了两个监视器，分别是notEmpty和notFull。这两个监视器的作用目前可以简单理解为标记分组，当该线程是put操作时，给他加上监视器notFull,标记这个线程是一个生产者；当线程是take操作时，给他加上监视器notEmpty，标记这个线程是消费者。 123456789101112131415161718192021//数据元素数组final Object[] items;//下一个待取出元素索引int takeIndex;//下一个待添加元素索引int putIndex;//元素个数int count;//内部锁final ReentrantLock lock;//消费者监视器private final Condition notEmpty;//生产者监视器private final Condition notFull; public ArrayBlockingQueue(int capacity, boolean fair) { //..省略其他代码 lock = new ReentrantLock(fair); notEmpty = lock.newCondition(); notFull = lock.newCondition();} put源码 12345678910111213141516171819202122232425262728public void put(E e) throws InterruptedException { checkNotNull(e); final ReentrantLock lock = this.lock; // 1.自旋拿锁 lock.lockInterruptibly(); try { // 2.判断队列是否满了 while (count == items.length) // 2.1如果满了，阻塞该线程，并标记为notFull线程， // 等待notFull的唤醒，唤醒之后继续执行while循环。 notFull.await(); // 3.如果没有满，则进入队列 enqueue(e); } finally { lock.unlock(); }}private void enqueue(E x) { // assert lock.getHoldCount() == 1; // assert items[putIndex] == null; final Object[] items = this.items; items[putIndex] = x; if (++putIndex == items.length) putIndex = 0; count++; // 4 唤醒一个等待的线程 notEmpty.signal();} 所有执行put操作的线程竞争lock锁，拿到了lock锁的线程进入下一步，没有拿到lock锁的线程自旋竞争锁。 判断阻塞队列是否满了，如果满了，则调用await方法阻塞这个线程，并标记为notFull（生产者）线程，同时释放lock锁,等待被消费者线程唤醒。 如果没有满，则调用enqueue方法将元素put进阻塞队列。注意这一步的线程还有一种情况是第二步中阻塞的线程被唤醒且又拿到了lock锁的线程。 唤醒一个标记为notEmpty（消费者）的线程。 take源码 1234567891011121314151617181920212223242526public E take() throws InterruptedException { final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { while (count == 0) notEmpty.await(); return dequeue(); } finally { lock.unlock(); }}private E dequeue() { // assert lock.getHoldCount() == 1; // assert items[takeIndex] != null; final Object[] items = this.items; @SuppressWarnings(\"unchecked\") E x = (E) items[takeIndex]; items[takeIndex] = null; if (++takeIndex == items.length) takeIndex = 0; count--; if (itrs != null) itrs.elementDequeued(); notFull.signal(); return x;} take操作和put操作的流程是类似的，总结一下take操作的流程： 所有执行take操作的线程竞争lock锁，拿到了lock锁的线程进入下一步，没有拿到lock锁的线程自旋竞争锁。 判断阻塞队列是否为空，如果是空，则调用await方法阻塞这个线程，并标记为notEmpty（消费者）线程，同时释放lock锁,等待被生产者线程唤醒。 如果没有空，则调用dequeue方法。注意这一步的线程还有一种情况是第二步中阻塞的线程被唤醒且又拿到了lock锁的线程。 唤醒一个标记为notFull（生产者）的线程。 应用场景 生产者-消费者模式 线程池中","link":"/2020/07/15/ThreadPool/"},{"title":"jvm","text":"Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。 JVM运行时数据区","link":"/2020/06/26/jvm/"},{"title":"basicconcurrency","text":"进程和线程的区别 进程是一个独立的运行环境，而线程是在进程中执行的一个任务。他们两个本质的区别是是否单独占有内存地址空间及其它系统资源（比如I/O）： 进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂。 进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高；一个线程崩溃可能影响整个程序的稳定性，可靠性较低。 进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。 另外一个重要区别是，进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位，即CPU分配时间的单位 。 上下文切换 CPU为每个进程分配一个时间段，称作它的时间片。如果在时间片结束时进程还在运行，则暂停这个进程的运行，并且CPU分配给另一个进程（这个过程叫做上下文切换）。如果进程在时间片结束前阻塞或结束，则CPU立即进行切换，不用等待时间片用完。 上下文切换（有时也称做进程切换或任务切换）是指 CPU 从一个进程（或线程）切换到另一个进程（或线程）。上下文是指某一时间点 CPU 寄存器和程序计数器的内容。 CPU通过为每个线程分配CPU时间片来实现多线程机制。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。 但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。 寄存器是cpu内部的少量的速度很快的闪存，通常存储和访问计算过程的中间值提高计算机程序的运行速度。 程序计数器是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体实现依赖于特定的系统。 举例说明 线程A - B 1.先挂起线程A，将其在cpu中的状态保存在内存中。 2.在内存中检索下一个线程B的上下文并将其在 CPU 的寄存器中恢复,执行B线程。 3.当B执行完，根据程序计数器中指向的位置恢复线程A。 实现多线程 我们在程序里面调用了start()方法后，虚拟机会先为我们创建一个线程，然后等到这个线程第一次得到时间片时再调用run()方法。 1.1 继承Thread类或者实现Runnable接口这两种方式，它们之间有什么优劣呢？ 由于Java“单继承，多实现”的特性，Runnable接口使用起来比Thread更灵活；Runnable接口出现更符合面向对象，将线程单独进行对象的封装；Runnable接口出现，降低了线程对象和线程任务的耦合性；如果使用线程时不需要使用Thread类的诸多方法，显然使用Runnable接口更为轻量；所以，我们通常优先使用“实现Runnable接口”这种方式来自定义线程类。 1.2 同时使用两种方法： 12345678public static void main(String[] args) { new Thread(() -&gt; System.out.println(\"我来自Runnable\")) { @Override public void run() { System.out.println(\"我来自Thread\"); } }.start(); } 输出：我来自Thread 线程的状态 RUNNABLE： 1234567/** * Thread state for a runnable thread. A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. */RUNNABLE, 处于RUNNABLE状态的线程在Java虚拟机中运行，也有可能在等待其他系统资源（比如I/O）。 Java线程的RUNNABLE状态其实是包括了传统操作系统线程的ready和running两个状态的。 线程的生命周期 1234567891011121314151617181920212223242526272829303132public synchronized void start() { /** * This method is not invoked for the main method thread or \"system\" * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state \"NEW\". */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group's list of threads * and the group's unstarted count can be decremented. */ group.add(this); boolean started = false; try { start0(); started = true; } finally { try { // 若线程启动失败，从线程组里移除该线程 if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ } }} 如何正确停止线程 线程中断机制是一种协作机制。通过中断操作并不能直接终止一个线程，而是通知需要被中断的线程自行处理。 Thread.interrupt()：中断线程。这里的中断线程并不会立即停止线程，而是设置线程的中断状态为true（默认是flase）； Thread.interrupted()：测试当前线程是否被中断。线程的中断状态受这个方法的影响，意思是调用一次使线程中断状态设置为true，连续调用两次会使得这个线程的中断状态重新转为false； Thread.isInterrupted()：测试当前线程是否被中断。与上面方法不同的是调用这个方法并不会影响线程的中断状态； 原理介绍：使用interrupt来通知，而不是强制 解读：想要停止线程，其实是如何正确的用interrupt通知那个线程，以及被停止的线程如何配合。 使用interrupt 普通情况下停止线程 123456789101112131415161718192021public class RightWayStopThreadWithoutSleep implements Runnable { public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(new RightWayStopThreadWithoutSleep()); thread.start(); Thread.sleep(1000); thread.interrupt(); } @Override public void run() { int num = 0; while (!Thread.currentThread().isInterrupted() &amp;&amp; num &lt;= Integer.MAX_VALUE / 2) { if (num % 10000 == 0) { System.out.println(num + \"是10000的倍数\"); } num++; } System.out.println(\"任务运行结束了\"); }} 线程可能被阻塞的情况下被停止 12345678910111213141516171819202122232425262728293031public class RightWayStopThreadWithSleep { public static void main(String[] args) throws InterruptedException { Runnable runnable = () -&gt; { int num = 0; try { while (num &lt; 300 &amp;&amp; !Thread.currentThread().isInterrupted()) { if (num % 100 == 0) { System.out.println(num + \"是100的倍数\"); } num++; } Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } }; Thread thread = new Thread(runnable); thread.start(); Thread.sleep(500); thread.interrupt(); }}/**0是100的倍数100是100的倍数200是100的倍数java.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at threadcoreknowledge.stopthreads.RightWayStopThreadWithSleep.lambda$main$0(RightWayStopThreadWithSleep.java:21) at java.lang.Thread.run(Thread.java:748)*/ 如果线程在每次迭代后被阻塞 如果在执行过程中，每次循环都会调用sleep或wait等方法，那么不需要每次迭代都检查是否已中断。 1234567891011121314151617181920212223public class RightWayStopThreadWithSleepEveryLoop { public static void main(String[] args) throws InterruptedException { Runnable runnable = () -&gt; { int num = 0; try { // 不需要做是否中断的检测 while (num &lt; 10000) { if (num % 100 == 0) { System.out.println(num + \"是100的倍数\"); } num++; Thread.sleep(10); } } catch (InterruptedException e) { e.printStackTrace(); } }; Thread thread = new Thread(runnable); thread.start(); Thread.sleep(5000); thread.interrupt(); }} 如果while里面放try/catch，会导致中断失效 因为sleep会清除中断信号，将中断标记位设置成 false（源码分析待补全） 12345678910111213141516171819202122public class CantInterrupt { public static void main(String[] args) throws InterruptedException { Runnable runnable = () -&gt; { int num = 0; while (num &lt; 10000 &amp;&amp; !Thread.currentThread().isInterrupted()) { if (num % 100 == 0) { System.out.println(num + \"是100的倍数\"); } num++; try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } }; Thread thread = new Thread(runnable); thread.start(); Thread.sleep(5000); thread.interrupt(); }} 实际开发中的两种最佳实践 不应屏蔽中断 优先选择：传递中断 catch了InterruptException之后的优先选择：在方法签名中抛出异常，那么在run()就会强制try/catch 1234567891011121314151617181920212223242526public class RightWaySropThreadInProd1 implements Runnable { public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(new RightWaySropThreadInProd1()); thread.start(); Thread.sleep(1000); thread.interrupt(); } @Override public void run() { while (true) { System.out.println(\"go\"); try { throwInMethod(); } catch (InterruptedException e) { // 保存日志，停止程序 System.out.println(\"保存日志\"); e.printStackTrace(); } } } private void throwInMethod() throws InterruptedException { Thread.sleep(1000); }} 不想或无法传递：恢复中断 在catch子语句中调用Thread.currentThread().interrupt()来恢复设置中断状态，以便在后续的执行中，依然能够检查到刚才发生了中断。（使得其他代码有办法知道它发生了中断） 12345678910111213141516171819202122232425262728public class RightWaySropThreadInProd2 implements Runnable { public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(new RightWaySropThreadInProd2()); thread.start(); Thread.sleep(1000); thread.interrupt(); } @Override public void run() { while (true) { if (Thread.currentThread().isInterrupted()) { System.out.println(\"程序运行结束\"); break; } reInterrupt(); } } private void reInterrupt() { try { Thread.sleep(1000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); e.printStackTrace(); } }} 响应中断的方法总结列表 Object.wait()/wait(long)/wait(long, int) Thread.sleep(long)/sleep(long, int) Thread.join()/join(long)/join(long, int) java.util.cocurrent.BlockingQueue.take()/put(E) java.util.cocurrent.locks.Lock.lockInterruptibly() java.util.cocurrent.CountDownLatch.await() java.util.cocurrent.CyclicBarrier.await() java.util.cocurrent.Exchanger.exchange(V) java.nio.channels.InterruptibleChannel相关方法 java.nio.channels.Selector相关方法 错误的停止方法 被弃用的stop，suspend，resume方法（待补全） stop() 弃用原因： 原因1：即刻停止run()方法中剩余的全部工作，包括在catch或finally语句中，并抛出ThreadDeath异常(通常情况下此异常不需要显示的捕获)，因此可能会导致一些清理性的工作的得不到完成，如文件，数据库等的关闭； 原因2：会立即释放该线程所持有的所有的锁，导致数据得不到同步的处理，出现数据不一致的问题； suspend() resume()弃用原因 suspend()和resume()必须要成对出现，否则非常容易发生死锁； 不推荐使用suspend()去挂起线程的原因，是因为suspend()在导致线程暂停的同时，并不会去释放任何锁资源。其他线程都无法访问被它占用的锁。直到对应的线程执行resume()方法后，被挂起的线程才能继续，从而其它被阻塞在这个锁的线程才可以继续执行。 如果一个线程在resume目标线程之前尝试持有这个重要的系统资源锁再去resume目标线程，这两条线程就相互死锁了，也就冻结线程。 用volatile设置boolean标记位 原因：如果线程发生阻塞了，它将无法执行判断标识位的代码，阻塞无法收到停止线程的通知。线程依然不能停止。 停止线程相关重要函数解析（待补全） interrupt方法 1234567891011121314public void interrupt() { if (this != Thread.currentThread()) checkAccess(); synchronized (blockerLock) { Interruptible b = blocker; if (b != null) { interrupt0(); // Just to set the interrupt flag b.interrupt(this); return; } } interrupt0();} 判断是否已被中断相关方法 static boolean interrupted() boolean isInterrupted() Thread.interrupted()的目的对象 线程的各个属性 线程的异常 代码举例： 123456789101112131415public class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler { private String name; public MyUncaughtExceptionHandler(String name) { this.name = name; } @Override public void uncaughtException(Thread t, Throwable e) { Logger logger = Logger.getAnonymousLogger(); logger.log(Level.WARNING, \"线程异常，终止啦\" + t.getName()); System.out.println(name + \"捕获了异常\" + t.getName() + \"异常\"); }} 123456789101112131415161718public class UseOwnUncaughtExceptionHandler implements Runnable { public static void main(String[] args) throws InterruptedException { Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandler(\"捕获器1\")); new Thread(new UseOwnUncaughtExceptionHandler(), \"MyThread-1\").start(); Thread.sleep(300); new Thread(new UseOwnUncaughtExceptionHandler(), \"MyThread-2\").start(); Thread.sleep(300); new Thread(new UseOwnUncaughtExceptionHandler(), \"MyThread-3\").start(); Thread.sleep(300); new Thread(new UseOwnUncaughtExceptionHandler(), \"MyThread-4\").start(); } @Override public void run() { throw new RuntimeException(); }} 输出： 1234567891011121314七月 11, 2020 4:02:09 下午 threadcoreknowledge.uncaughtexception.MyUncaughtExceptionHandler uncaughtException警告: 线程异常，终止啦MyThread-1捕获器1捕获了异常MyThread-1异常七月 11, 2020 4:02:09 下午 threadcoreknowledge.uncaughtexception.MyUncaughtExceptionHandler uncaughtException警告: 线程异常，终止啦MyThread-2捕获器1捕获了异常MyThread-2异常七月 11, 2020 4:02:09 下午 threadcoreknowledge.uncaughtexception.MyUncaughtExceptionHandler uncaughtException警告: 线程异常，终止啦MyThread-3捕获器1捕获了异常MyThread-3异常七月 11, 2020 4:02:10 下午 threadcoreknowledge.uncaughtexception.MyUncaughtExceptionHandler uncaughtException警告: 线程异常，终止啦MyThread-4捕获器1捕获了异常MyThread-4异常Process finished with exit code 0 Thread及Object中线程相关的重要方法 类 方法名 简介 Thread sleep相关 相关，指重写的方法 join 等待其他线程执行完毕 yield相关 放弃以获取到的CPU资源 currentThread 获取当前执行线程的引用 start，run相关 启动线程相关 interrupt相关 中断线程 stop()，suspend()，resume()相关 已废弃 Object wait/notify/notifyAll相关 让线程暂时休眠或唤醒 currentThread()：静态方法，返回对当前正在执行的线程对象的引用；start()：开始执行线程的方法，java虚拟机会调用线程内的run()方法；yield()：yield在英语里有放弃的意思，同样，这里的yield()指的是当前线程愿意让出对当前处理器的占用。这里需要注意的是，就算当前线程调用了yield()方法，程序在调度的时候，也还有可能继续运行这个线程的；sleep()：静态方法，使当前线程睡眠一段时间；join()：使当前线程等待另一个线程执行完毕之后再继续执行，内部调用的是Object类的wait方法实现的；","link":"/2020/07/11/basicconcurrency/"},{"title":"logs","text":"Log4j.properties配置详解 Loggers组件这五个级别是有顺序的，DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，分别用来指定这条日志信息的重要程度。 Log4j有一个规则：只输出级别不低于设定级别的日志信息，假设Loggers级别设定为INFO，则INFO、WARN、ERROR和FATAL级别的日志信息都会输出，而级别比INFO低的DEBUG则不会输出。 配置日志信息输出目的地（appender）1log4j.appender.appenderName = className appenderName：自定义appderName，在log4j.rootLogger设置中使用；className：可设值如下： (1) org.apache.log4j.ConsoleAppender（控制台）选项 Threshold=WARN：指定日志信息的最低输出级别，默认为DEBUG。 ImmediateFlush=true：表示所有消息都会被立即输出，设为false则不输出，默认值是true。 Target=System.err：默认值是System.out。 (2) org.apache.log4j.FileAppender（文件）选项 Threshold=WARN：指定日志信息的最低输出级别，默认为DEBUG。 ImmediateFlush=true：表示所有消息都会被立即输出，设为false则不输出，默认值是true。 Append=false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。 File=D:/logs/logging.log4j：指定消息输出到logging.log4j文件中。 (3) org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）选项 Threshold=WARN：指定日志信息的最低输出级别，默认为DEBUG。 ImmediateFlush=true：表示所有消息都会被立即输出，设为false则不输出，默认值是true。 Append=false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。 File=D:/logs/logging.log4j：指定当前消息输出到logging.log4j文件中。 DatePattern=’.’yyyy-MM：每月滚动一次日志文件，即每月产生一个新的日志文件。当前月的日志文件名为logging.log4j，前一个月的日志文件名为logging.log4j.yyyy-MM。 另外，也可以指定按周、天、时、分等来滚动日志文件，对应的格式如下： ‘.’yyyy-MM：每月 ‘.’yyyy-ww：每周 ‘.’yyyy-MM-dd：每天 ‘.’yyyy-MM-dd-a：每天两次 ‘.’yyyy-MM-dd-HH：每小时 ‘.’yyyy-MM-dd-HH-mm：每分钟 (4) org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）选项 Threshold=WARN：指定日志信息的最低输出级别，默认为DEBUG。 ImmediateFlush=true：表示所有消息都会被立即输出，设为false则不输出，默认值是true。 Append=false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。 File=D:/logs/logging.log4j：指定消息输出到logging.log4j文件中。 MaxFileSize=100KB：后缀可以是KB, MB 或者GB。在日志文件到达该大小时，将会自动滚动，即将原来的内容移到logging.log4j.1文件中。 MaxBackupIndex=2：指定可以产生的滚动文件的最大数，例如，设为2则可以产生logging.log4j.1，logging.log4j.2两个滚动文件和一个logging.log4j文件。 （5）org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方） 配置日志信息的输出格式（Layout）1log4j.appender.appenderName.layout=className className：可设值如下： (1) org.apache.log4j.HTMLLayout（以HTML表格形式布局） LocationInfo=true：输出java文件名称和行号，默认值是false。 Title=My Logging： 默认值是Log4J Log Messages。 (2) org.apache.log4j.PatternLayout（可以灵活地指定布局模式） ConversionPattern=%m%n：设定以怎样的格式显示消息。 格式化符号说明： %p：输出日志信息的优先级，即DEBUG，INFO，WARN，ERROR，FATAL。 %d：输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，如：%d{yyyy/MM/dd HH:mm:ss,SSS}。 %r：输出自应用程序启动到输出该log信息耗费的毫秒数。 %t：输出产生该日志事件的线程名。 %l：输出日志事件的发生位置，相当于%c.%M(%F:%L)的组合，包括类全名、方法、文件名以及在代码中的行数。例如：test.TestLog4j.main(TestLog4j.java:10)。 %c：输出日志信息所属的类目，通常就是所在类的全名。 %M：输出产生日志信息的方法名。 %F：输出日志消息产生时所在的文件名称。 %L:：输出代码中的行号。 %m:：输出代码中指定的具体日志信息。 %n：输出一个回车换行符，Windows平台为”\\r\\n”，Unix平台为”\\n”。 %x：输出和当前线程相关联的NDC(嵌套诊断环境)，尤其用到像java servlets这样的多客户多线程的应用中。 %%：输出一个”%”字符。 另外，还可以在%与格式字符之间加上修饰符来控制其最小长度、最大长度、和文本的对齐方式。如： c：指定输出category的名称，最小的长度是20，如果category的名称长度小于20的话，默认的情况下右对齐。 %-20c：”-“号表示左对齐。 %.30c：指定输出category的名称，最大的长度是30，如果category的名称长度大于30的话，就会将左边多出的字符截掉，但小于30的话也不会补空格。 （3）org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串） （4）org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）","link":"/2020/07/12/logs/"},{"title":"springframework","text":"项目导入IDEA 环境：Windows，JDK8，Gradle 6.5.1，IDEA 2020.1.3 进入 https://github.com/spring-projects/spring-framework，选择版本5.2.X，下载zip或clone到本地； 编辑项目目录下的build.gradle，全局搜索allprojects，编辑其repositories属性，配置阿里云镜像，如下： 123456repositories { maven { url 'http://maven.aliyun.com/nexus/content/groups/public/' } maven{ url 'http://maven.aliyun.com/nexus/content/repositories/jcenter'} mavenCentral() maven { url \"https://repo.spring.io/libs-spring-framework-build\" }} 进入项目根目录下，预编译spring-oxm，在命令行中执行： 1gradlew :spring-oxm:compileTestJava (需耐心等待3-5分钟左右…) 成功后打印BUILD SUCCESSFUL 导入项目至idea； 移除spring-aspects模块； 阅读reference文档 GA：General Availability，官方正式发布的稳定版本（RELEASE，Stable，Final） RC：Release Candidate，发行候选版本，基本不再加入新的功能 Alpha：内部测试版本，bug较多，功能不全 Beta：公开测试版本，比Alpha晚些，还会加功能，修bug M：Milestone，开发期发行版本，边开发边发行 单一职责原则 门面模式 facade pattern 子系统的外部与其内部的通信必须通过统一的对象进行 提供一个高层次的接口，使得子系统更易于使用 适配器模式 泛型 让数据类型变得参数化 定义泛型时，对应的数据类型是不确定的； 泛型方法被调用时，会指定具体类型； 核心目标：解决容器类型在编译时安全检查的问题 泛型类 泛型的参数不支持基本类型 泛型相关的信息不会进入到运行阶段 能否在泛型里面使用具备继承关系的类？不可以 解决办法： 使用通配符 ?，但是会使得泛型的类型检查失去意义； 给泛型加入上边界 ? extends E； 给泛型加入下边界 ? super E； 泛型接口 泛型方法 123456789101112131415161718192021222324@Datapublic class GenericClassExample&lt;T&gt; { /** * member这个成员变量的类型为T,T的类型由外部指定 */ private T member; public GenericClassExample(T member) { this.member = member; } public static &lt;E&gt; void printArray(E[] inputArray) { for (E element : inputArray) { System.out.printf(\"%s\", element); System.out.printf(\" \"); } System.out.println(); } public T handleSomething(T target) { return target; }} 泛型方法中的泛型标识符可独立于泛型类存在的，而泛型类中其他方法受制于泛型标识符的 泛型字母的含义 E - Element 在集合中使用，因为集合中存放的是元素； T - Type Java类； K - Key 键； V - Value 值； N - Number 数值类型； Servlet原理总结 减少Servlet的数量 参照SpringMVC，仅通过DispatcherServlet进行请求派发； 拦截所有请求 解析请求 派发给对应的Controller里面的方法进行处理 简单工厂模式 定义一个工厂类，根据传入的参数值不同返回不同的实例 特点：被创建的实例具有共同的父类或接口 适用场景： 需要创建的对象较少； 客户端不关心对象的创建过程； 优点：可以对创建的对象进行“加工”，对客户端隐藏相关细节； 缺点：因创建逻辑复杂或创建对象过多而造成代码臃肿；新增、删除子类均会违反开闭原则； 开闭原则（待补全） 工厂方法模式 定义一个用于创建对象的接口，让子类决定实例化哪一个类 对类的实例化延迟到子类 优点： 遵循开闭原则 对客户端隐藏对象的创建细节 遵循单一职责 缺点： 增加子类的时候“拖家带口” 只支持同一类产品的创建 抽象工厂 提供一个创建一系列相关或相互依赖对象的接口 抽象工厂模式侧重的是同一产品族 工厂方法模式更加侧重于同一产品等级 解决了工厂模式只支持生产一种产品的弊端 新增一个产品族，只需要增加一个新的具体工厂，不需要修改代码； IOCSpring IOC容器使用了工厂模式+反射机制 反射：允许程序在运行时来进行自我检查并且对内部的成员进行操作 1）作用： 在运行时判断任意一个对象所属的类； 在运行时获取类的对象； 在运行时访问Java对象的属性、方法、构造方法等； 2）java.lang.reflect 类库里主要的类 Field：表示类中的成员变量 Method：表示类中的方法 Constructor：表示类的构造方法 Array：该类提供了动态创建数组和访问数组元素的静态方法 3）反射依赖的Class JVM中只有唯一一个和类相对应的Class对象来描述其类型信息。 4）获取Class对象的三种方式： Object -&gt; getClass() 任何数据类型（包括基本数据类型）都有一个“静态”的class属性 通过Class类的静态方法：forName(String className) （常用） 123456789101112131415public class ReflectTarget { public static void main(String[] args) throws ClassNotFoundException { ReflectTarget reflectTarget = new ReflectTarget(); // 第一种方式获取class对象 Class reflectTargetClass1 = reflectTarget.getClass(); // 第二种 Class reflectTargetClass2 = ReflectTarget.class; System.out.println(reflectTargetClass1 == reflectTargetClass2); // 第三种 Class reflectTargetClass3 = Class.forName(\"demo.reflect.ReflectTarget\"); System.out.println(reflectTargetClass2 == reflectTargetClass3); }} 5）获取并操作构造函数 1234567891011121314151617181920212223242526272829303132333435// 获取所有\"公有的\"的构造方法@CallerSensitivepublic Constructor&lt;?&gt;[] getConstructors() throws SecurityException { checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true); return copyConstructors(privateGetDeclaredConstructors(true));}// 获取所有的构造方法(包括private public default protected)@CallerSensitivepublic Constructor&lt;?&gt;[] getDeclaredConstructors() throws SecurityException { checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true); return copyConstructors(privateGetDeclaredConstructors(false));}// 获取单个的\"公有的\"构造方法@CallerSensitivepublic Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException, SecurityException { checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true); return getConstructor0(parameterTypes, Member.PUBLIC);}// 获取某个构造方法(包括private public default protected)@CallerSensitivepublic Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException, SecurityException { checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true); return getConstructor0(parameterTypes, Member.DECLARED);}// 调用构造方法Constructor -&gt; newInstance(Object... initargs) // 暴力访问(忽略掉访问修饰符)Constructor -&gt; setAccessible(true) 6）获取并操作成员变量 12345678910111213141516171819202122232425262728293031323334353637383940// 获取所有的\"公有字段\" 包含继承字段@CallerSensitivepublic Field[] getFields() throws SecurityException { checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true); return copyFields(privateGetPublicFields(null));}// 获取所有字段(包括private修饰的) 不包含继承的字段@CallerSensitivepublic Field[] getDeclaredFields() throws SecurityException { checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true); return copyFields(privateGetDeclaredFields(false));}// 获取某个\"公有的\"字段 包含继承字段@CallerSensitivepublic Field getField(String name) throws NoSuchFieldException, SecurityException { checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true); Field field = getField0(name); if (field == null) { throw new NoSuchFieldException(name); } return field;}// 获取某个字段(可以是私有的) 不包括继承字段@CallerSensitivepublic Field getDeclaredField(String name) throws NoSuchFieldException, SecurityException { checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true); Field field = searchFields(privateGetDeclaredFields(false), name); if (field == null) { throw new NoSuchFieldException(name); } return field;}// 设置字段的值 obj:要设置的字段所在的对象 value:要为字段设置的值Field -&gt; public void set(Object obj, Object value); 7）获取并操作成员方法 1234567891011121314151617181920212223242526272829303132333435363738// 获取所有的\"公有方法\" 包含了父类的方法和Object类@CallerSensitivepublic Method[] getMethods() throws SecurityException { checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true); return copyMethods(privateGetPublicMethods());}// 获取所有的成员方法，包括私有的，不包含继承的@CallerSensitivepublic Method[] getDeclaredMethods() throws SecurityException { checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true); return copyMethods(privateGetDeclaredMethods(false));}// name:方法名 Class...:形参的Class类型对象public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException, SecurityException { checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true); Method method = getMethod0(name, parameterTypes, true); if (method == null) { throw new NoSuchMethodException(getName() + \".\" + name + argumentTypesToString(parameterTypes)); } return method;}@CallerSensitivepublic Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException, SecurityException { checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true); Method method = searchMethods(privateGetDeclaredMethods(false), name, parameterTypes); if (method == null) { throw new NoSuchMethodException(getName() + \".\" + name + argumentTypesToString(parameterTypes)); } return method;}// 调用方法 obj:要调用方法的对象 args:调用方法时传递的实参Method -&gt; public Object invoke(Object obj, Object... args); 8）反射的获取源 用XML来保存类相关的信息以供反射调用； 用注解来保存类相关的信息以供反射调用； 注解：提供一种为程序元素设置元数据的方法 元数据是添加到程序元素如方法、字段、类和包上的额外信息。 1）功能 作为特定的标记，用于告诉编译器一些信息； 编译时动态处理，如动态生成代码； 运行时动态处理，作为额外信息的载体，如获取注解信息； 2）注解分类 标准注解：Override、Deprecated、SuppressWarnings 元注解：@Retention、@Target、@Inherited、@Documented 自定义注解 3）元注解 ​ @Target：注解的作用目标 ​ @Retention：注解的生命周期 ​ @Documented：注解是否应当被包含在JavaDoc文档中 ​ @Inherited：是否允许子类继承该注解 单例模式（待总结） 使用反射时恶汉和懒汉模式都不能保证单例，所以采取枚举解决（枚举原理待补全） 需要实现的点 创建注解 提取标记对象 extractPackageClass 指定范围，获取范围内的所有类； 遍历所有类，获取被注解标记的类并加载进容器里； 实现容器 保存Class对象及其实例的载体 容器的加载（配置的管理与获取，获取指定范围内的Class对象，依据配置提取Class对象，连同实例一并存入容器） 容器的操作方式（涉及到容器的增删改查：增加、删除操作，根据Class获取对应实例，获取所有的Class和实例，通过注解来获取被注解标注的Class，通过超类获取对应的子类Class，获取容器载体保存Class的数量） 依赖注入 定义相关的注解标签 实现创建被注解标记的成员变量实例，并将其注入到成员变量里 依赖注入的使用 Spring框架有多种作用域 singleton prototype request session globalsession IOC源码学习 场景问题 BeanFactory和factoryBean有什么联系和区别","link":"/2020/07/11/springframework/"},{"title":"synchronized","text":"synchronizedJava多线程的锁都是基于对象的，Java中的每一个对象都可以作为一个锁。 还有一点需要注意的是，我们常听到的类锁其实也是对象锁。 Java类只有一个Class对象（可以有多个实例对象，多个实例共享这个Class对象），而Class对象也是特殊的Java对象。所以我们常说的类锁，其实就是Class对象的锁。 用法 1234567891011121314151617// 关键字在实例方法上，锁为当前实例public synchronized void instanceLock() { // code}// 关键字在静态方法上，锁为当前Class对象public static synchronized void classLock() { // code}// 关键字在代码块上，锁为括号里面的对象public void blockLock() { Object o = new Object(); synchronized (o) { // code }} 所谓“临界区”，指的是某一块代码区域，它同一时刻只能由一个线程执行。在上面的例子中，如果synchronized关键字在方法上，那临界区就是整个方法内部。而如果是使用synchronized代码块，那临界区就指的是代码块内部的区域。 12345678910111213141516171819202122232425// 等价情况1// 关键字在实例方法上，锁为当前实例public synchronized void instanceLock() { // code}// 关键字在代码块上，锁为括号里面的对象public void blockLock() { synchronized (this) { // code }}// 等价情况2// 关键字在静态方法上，锁为当前Class对象public static synchronized void classLock() { // code}// 关键字在代码块上，锁为括号里面的对象public void blockLock() { synchronized (this.getClass()) { // code }} 锁升级在Java 6 及其以后，一个对象其实有四种锁状态，它们级别由低到高依次是：无锁状态，偏向锁状态，轻量级锁状态，重量级锁状态。 一个对象的“锁”的信息存放在什么地方？ Java对象头 Mark Word的格式： 锁状态 29bit/61bit 1bit是否为偏向锁 2bit锁标志位 无锁 0 01 偏向锁 线程ID 1 01 轻量级锁 指向栈中锁记录的指针 此时这一位不用于标识偏向锁 00 重量级锁 指向互斥量（重量级锁）的指针 此时这一位不用于标识偏向锁 10 GC标记 此时这一位不用于标识偏向锁 11 当对象状态为偏向锁时，Mark Word存储的是偏向的线程ID；当状态为轻量级锁时，Mark Word存储的是指向线程栈中Lock Record的指针；当状态为重量级锁时，Mark Word为指向堆中的monitor对象的指针。 偏向锁Hotspot的作者经研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，于是引入了偏向锁。 偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。也就是说，偏向锁在资源无竞争情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能。 实现原理 一个线程在第一次进入同步块时，会在对象头和栈帧中的锁记录里存储锁的偏向的线程ID。当下次该线程进入这个同步块时，会去检查锁的Mark Word里面是不是放的自己的线程ID。 如果是，表明该线程已经获得了锁，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁 ；如果不是，就代表有另一个线程来竞争这个偏向锁。这个时候会尝试使用CAS来替换Mark Word里面的线程ID为新线程的ID，这个时候要分两种情况： 成功，表示之前的线程不存在了， Mark Word里面的线程ID为新线程的ID，锁不会升级，仍然为偏向锁； 失败，表示之前的线程仍然存在，那么暂停之前的线程，设置偏向锁标识为0，并设置锁标志位为00，升级为轻量级锁，会按照轻量级锁的方式进行竞争锁。 撤销偏向锁 偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时， 持有偏向锁的线程才会释放锁。 偏向锁升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，大概过程如下： 在一个安全点（在这个时间点上没有字节码正在执行）停止拥有锁的线程； 遍历线程栈，如果存在锁记录的话，需要修复锁记录和Mark Word，使其变成无锁状态； 唤醒被停止的线程，将当前锁升级成轻量级锁； 所以，如果应用程序里所有的锁通常处于竞争状态，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭： 1-XX:UseBiasedLocking=false 轻量级锁多个线程在不同时段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞。针对这种情况，JVM采用轻量级锁来避免线程的阻塞与唤醒。 轻量级锁的加锁 JVM会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，Displaced Mark Word。如果一个线程获得锁时发现是轻量级锁，会把锁的Mark Word复制到自己的Displaced Mark Word里面。 然后线程尝试用CAS将锁的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示Mark Word已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁。 JDK采用适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。 自旋也不是一直进行下去的，如果自旋到一定程度（和JVM、操作系统相关），依然没有获取到锁，称为自旋失败，那么这个线程会阻塞。同时这个锁就会升级成重量级锁。 轻量级锁的释放 在释放锁时，当前线程会使用CAS操作将Displaced Mark Word的内容复制回锁的Mark Word里面。如果没有发生竞争，那么这个复制的操作会成功。如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么CAS操作会失败，此时会释放锁并唤醒被阻塞的线程。 重量级锁重量级锁依赖于操作系统的互斥量（mutex） 实现的，而操作系统中线程间状态的转换需要相对比较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗CPU。 锁的升级流程每一个线程在准备获取共享资源时： 第一步，检查MarkWord里面是不是放的自己的ThreadId ,如果是，表示当前线程是处于 “偏向锁”； 第二步，如果MarkWord不是自己的ThreadId，锁升级，这时候，用CAS来执行切换，新的线程根据MarkWord里面现有的ThreadId，通知之前线程暂停，之前线程将Markword的内容置为空； 第三步，两个线程都把锁对象的HashCode复制到自己新建的用于存储锁的记录空间，接着开始通过CAS操作， 把锁对象的MarKword的内容修改为自己新建的记录空间的地址的方式竞争MarkWord； 第四步，第三步中成功执行CAS的获得资源，失败的则进入自旋； 第五步，自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于 轻量级锁的状态，如果自旋失败； 第六步，进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己； 各种锁的优缺点对比 锁 优点 缺点 适用场景 偏向锁 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。 如果线程间存在锁竞争，会带来额外的锁撤销的消耗。 适用于只有一个线程访问同步块场景。 轻量级锁 竞争的线程不会阻塞，提高了程序的响应速度。 如果始终得不到锁竞争的线程使用自旋会消耗CPU。 追求响应时间。同步块执行速度非常快。 重量级锁 线程竞争不使用自旋，不会消耗CPU。 线程阻塞，响应时间缓慢。 追求吞吐量。同步块执行时间较长。","link":"/2020/07/14/synchronized/"},{"title":"volatile","text":"volatileJMMJMM的抽象：主内存和本地内存 JMM有以下规定： ​ 所有变量都存储在主内存中，同时每个线程也有自己独立的工作内存，工作内存中的变量内容是主内存中的拷贝； ​ 线程不能直接读写主内存中的变量，而是只操作自己工作内存中的变量，然后再同步到主内存中； ​ 主内存是多个线程共享的，但线程间不共享工作内存，如果线程间需要通信，必须借助主内存中转来完成； 为什么会有可见性问题 CPU有多级缓存，导致读的数据过期； 高速缓存的容量比主内存小，但是速度仅次于寄存器，所以在CPU和主内存之间就多了Cache层； 线程间的对于共享变量的可见性问题不是直接由多核引起的，而是由多缓存引起的； 如果所有核心都只用一个缓存，那么就不存在内存可见性问题了； 每个核心都会将自己需要的数据读到独占缓存中，数据修改后也是写入到缓存中，然后等待刷入主存中。所以会导致有些核心取到的值是一个过期的值； 重排序与happens-before 为什么存在重排序？为什么可以提高性能？ 12a = b + cd = e - f 先加载b、c（注意，即有可能先加载b，也有可能先加载c），但是在执行add(b,c)的时候，需要等待b、c装载结束才能继续执行，也就是增加了停顿，那么后面的指令也会依次有停顿,这降低了计算机的执行效率。 为了减少这个停顿，我们可以先加载e和f,然后再去加载add(b,c),这样做对程序（串行）是没有影响的,但却减少了停顿。既然add(b,c)需要停顿，那还不如去做一些有意义的事情。 指令重排对于提高CPU处理性能十分必要。虽然由此带来了乱序的问题，但是这点牺牲是值得的。 指令重排的类型 编译器优化重排：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序； 指令并行重排：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序； 内存系统重排：由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差； happens-before happens-before原则 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前； 两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么JMM也允许这样的重排序； 天然的happens-before关系 程序顺序规则：一个线程中的每一个操作，happens-before于该线程中的任意后续操作； 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁； volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读； 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C； start规则：如果线程A执行操作ThreadB.start()启动线程B，那么A线程的ThreadB.start（）操作happens-before于线程B中的任意操作； join规则：如果线程A执行操作ThreadB.join（）并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回； volatile 两个作用 保证变量的内存可见性； 禁止volatile变量与普通变量重排序（JSR133提出，Java 5 开始才有这个“增强的volatile内存语义”）； 原理 1）可见性实现： 修改volatile变量时会强制将修改后的值刷新的主内存中； 修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值； 2）禁止重排序实现： JVM限制处理器的重排序 —— 内存屏障 硬件层面，内存屏障分两种：读屏障（Load Barrier）和写屏障（Store Barrier）。 内存屏障有两个作用： 阻止屏障两侧的指令重排序；强制把写缓冲区/高速缓存中的脏数据等写回主内存，或者让缓存中相应的数据失效；（注意这里的缓存主要指的是CPU缓存，如L1，L2等） 编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。编译器选择了一个比较保守的JMM内存屏障插入策略，这样可以保证在任何处理器平台，任何程序中都能得到正确的volatile内存语义。这个策略是： 在每个volatile写操作前插入一个StoreStore屏障； 在每个volatile写操作后插入一个StoreLoad屏障； 在每个volatile读操作后插入一个LoadLoad屏障； 在每个volatile读操作后再插入一个LoadStore屏障； 再介绍一下volatile与普通变量的重排序规则: 如果第一个操作是volatile读，那无论第二个操作是什么，都不能重排序； 如果第二个操作是volatile写，那无论第一个操作是什么，都不能重排序； 如果第一个操作是volatile写，第二个操作是volatile读，那不能重排序； 应用 1）单例模式 —— 双重锁检查 12345678910111213141516171819public class Singleton { private volatile static Singleton instance; private Singleton() { } public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; }} 如果这里的变量声明不使用volatile关键字，则可能会发生错误的。它可能会被重排序： instance = new Singleton(); 123456789// 可以分解为以下三个步骤1 memory=allocate();// 分配内存 相当于c的malloc2 ctorInstanc(memory) //初始化对象3 s=memory //设置s指向刚分配的地址// 上述三个步骤可能会被重排序为 1-3-2，也就是：1 memory=allocate();// 分配内存 相当于c的malloc3 s=memory //设置s指向刚分配的地址2 ctorInstanc(memory) //初始化对象 而一旦假设发生了这样的重排序，比如线程A执行了步骤1和步骤3，但是步骤2还没有执行完。这个时候另一个线程B执行到了if (instance == null)，它会判定instance不为空，然后直接返回了一个未初始化完成的instance！","link":"/2020/07/13/volatile/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"concurrent","slug":"concurrent","link":"/tags/concurrent/"},{"name":"lc","slug":"lc","link":"/tags/lc/"},{"name":"lcof","slug":"lcof","link":"/tags/lcof/"},{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"}],"categories":[{"name":"剑指offer","slug":"剑指offer","link":"/categories/%E5%89%91%E6%8C%87offer/"}]}