{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/06/25/hello-world/"},{"title":"jvm","text":"Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。JVM运行时数据区","link":"/2020/06/26/jvm/"},{"title":"Lcof09","text":"Lcof 09.用两个栈实现队列 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 1234567891011121314151617181920212223242526272829303132333435class CQueue { Stack in; Stack out; int size; public CQueue() { in = new Stack&lt;&gt;(); out = new Stack&lt;&gt;(); size=0; } public void appendTail(int value) { in.push(value); size++; } public int deleteHead() { if(size==0){ return -1; } if (out.isEmpty()) { while (!in.isEmpty()) { out.push(in.pop()); } } size--; return (int) out.pop(); }}/** * Your CQueue object will be instantiated and called as such: * CQueue obj = new CQueue(); * obj.appendTail(value); * int param_2 = obj.deleteHead(); */ 优化：因为Stack继承了Vector接口，而Vector底层是一个Object[]数组，所以要考虑空间扩容和移位的问题。 可以使用LinkedList来做Stack的容器，其本身结构是个双向链表，扩容消耗少。 1234567891011121314151617181920212223class CQueue { LinkedList&lt;Integer&gt; stack1; LinkedList&lt;Integer&gt; stack2; public CQueue() { stack1 = new LinkedList&lt;&gt;(); stack2 = new LinkedList&lt;&gt;(); } public void appendTail(int value) { stack1.add(value); } public int deleteHead() { if (stack2.isEmpty()) { if (stack1.isEmpty()) return -1; while (!stack1.isEmpty()) { stack2.add(stack1.pop()); } return stack2.pop(); } else return stack2.pop(); }} 关系图","link":"/2020/06/27/Lcof09/"},{"title":"Lcof10_1","text":"Lcof 10-1.斐波那契数列 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下： F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 1234567891011class Solution { public int fib(int n) { if (n == 0) { return 0; } else if (n == 1) { return 1; } else { return fib(n - 1) + fib(n - 2); } }} 提交结果：超时 原因： 大量重复的递归计算。 优化： 1234567891011class Solution { public int fib(int n) { int a = 0, b = 1, sum; for(int i = 0; i &lt; n; i++){ sum = (a + b) % 1000000007; a = b; b = sum; } return a; }}","link":"/2020/06/27/Lcof10-1/"}],"tags":[{"name":"lcof","slug":"lcof","link":"/tags/lcof/"},{"name":"dp","slug":"dp","link":"/tags/dp/"}],"categories":[]}